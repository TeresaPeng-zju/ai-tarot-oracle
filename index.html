<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot Oracle: The Void</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;600&display=swap'); /* ÂºïÂÖ•‰∏≠ÊñáÂ≠ó‰Ωì */

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Cinzel', 'Noto Serif SC', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* ÈÄöÁî®Ê∑°ÂÖ•Ê∑°Âá∫Á±ª */
        .fade-enter { opacity: 0; animation: fadeIn 1s forwards; }
        .fade-exit { opacity: 1; animation: fadeOut 1s forwards; pointer-events: none; }
        @keyframes fadeIn { to { opacity: 1; } }
        @keyframes fadeOut { to { opacity: 0; } }

        /* ==================== Èò∂ÊÆµ1ÔºöÊèêÈóÆÂ±Ç (Intro Layer) ==================== */
        #intro-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
        }
        .intro-text {
            color: #ccc; font-size: 18px; letter-spacing: 3px; margin-bottom: 40px;
            text-shadow: 0 0 10px rgba(255,255,255,0.3); text-align: center;
        }
        .soul-input {
            background: transparent; border: none; border-bottom: 1px solid rgba(212, 175, 55, 0.5);
            width: 300px; padding: 10px; color: #d4af37; font-size: 20px; text-align: center;
            font-family: 'Noto Serif SC', serif; outline: none; transition: 0.5s;
        }
        .soul-input:focus { border-bottom: 1px solid #d4af37; width: 400px; }
        .soul-input::placeholder { color: #444; font-style: italic; }
        
        .start-btn {
            margin-top: 60px; padding: 12px 40px; background: transparent;
            border: 1px solid #444; color: #888; font-family: 'Cinzel', serif; letter-spacing: 2px;
            cursor: pointer; transition: 0.5s; border-radius: 2px;
        }
        .start-btn:hover { border-color: #d4af37; color: #d4af37; box-shadow: 0 0 20px rgba(212,175,55,0.2); }

        /* ==================== Èò∂ÊÆµ2ÔºöÊ∏∏ÊàèUIÂ±Ç (Play Layer) ==================== */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; 
            pointer-events: none; opacity: 0; transition: opacity 1s;
        }
        #ui-layer.active { opacity: 1; pointer-events: none; } /* inner elements have pointer-events auto */

        /* È°∂ÈÉ®Áä∂ÊÄÅÊ†è */
        #status-bar { 
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 60px; opacity: 0.8;
        }
        .status-item { display: flex; flex-direction: column; align-items: center; gap: 8px; opacity: 0.2; transition: 0.4s; color: #888; }
        .status-icon { font-size: 24px; filter: drop-shadow(0 0 5px rgba(0,0,0,0.5)); }
        .status-label { font-size: 10px; letter-spacing: 2px; text-transform: uppercase; }
        .status-item.active { opacity: 1; color: #d4af37; transform: translateY(-5px); text-shadow: 0 0 15px rgba(212, 175, 55, 0.6); }

        /* ÂéÜÂè≤ËÆ∞ÂΩï */
        #history-bar { position: absolute; top: 30px; left: 30px; display: flex; gap: 15px; pointer-events: auto; }
        .history-slot { display: flex; flex-direction: column; align-items: center; width: 50px; opacity: 0; animation: fadeSlideIn 0.8s forwards; }
        @keyframes fadeSlideIn { from { opacity:0; transform:translateY(-20px); } to { opacity:1; transform:translateY(0); } }
        .history-img-box {
            width: 36px; height: 60px; border: 1px solid rgba(212, 175, 55, 0.4);
            box-shadow: 0 0 10px rgba(0,0,0,0.8); border-radius: 2px; overflow: hidden; margin-bottom: 5px;
        }
        .history-img-box img { width: 100%; height: 100%; object-fit: cover; }
        .history-slot.reversed .history-img-box img { transform: rotate(180deg); }
        .history-text { font-size: 9px; color: #aaa; text-align: center; line-height: 1.2; font-family: 'Noto Serif SC'; }
        .history-text span.rev-mark { color: #ff6b6b; font-size: 8px; display: block; }

        /* Âç°ÁâåËØ¶ÊÉÖ */
        #card-detail { 
            position: absolute; bottom: 2%; left: 50%; transform: translateX(-50%); 
            text-align: center; opacity: 0; transition: opacity 1s; width: 100%; max-width: 700px;
        }
        #card-name { font-size: 42px; color: #d4af37; letter-spacing: 5px; margin-bottom: 10px; text-shadow: 0 2px 20px rgba(0,0,0,1); }
        #card-sub { font-size: 14px; color: #888; margin-bottom: 25px; letter-spacing: 3px; text-transform: uppercase; display: none; }
        #card-desc { font-size: 18px; color: #ddd; text-shadow: 0 2px 4px #000; line-height: 1.8; font-family: 'Noto Serif SC', serif; display: none;}
        #burn-hint {  font-size: 12px; color: rgba(255,255,255,0.6); letter-spacing: 2px; animation: breathe 3s infinite; }
        @keyframes breathe { 0%,100%{opacity:0.4} 50%{opacity:1} }

        /* ==================== Èò∂ÊÆµ3ÔºöËß£ËØªÂ±Ç (Reading Layer) ==================== */
        #reading-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            display: none; flex-direction: column; justify-content: flex-start; align-items: center;
            opacity: 0; transition: opacity 1s; padding: 40px 20px;
            overflow: hidden;
        }
        #reading-content { 
            width: 100%; 
            max-width: 700px; 
            text-align: center; 
            display: flex; 
            flex-direction: column; 
            height: 100%;
            max-height: 100vh;
            padding: 0 20px;
        }
        #reading-title { 
            color: #d4af37; 
            font-size: 24px; 
            margin-bottom: 30px; 
            letter-spacing: 4px; 
            flex-shrink: 0;
        }
        #reading-text { 
            color: #eee; 
            font-size: 16px; 
            line-height: 2; 
            font-family: 'Noto Serif SC'; 
            white-space: pre-wrap; 
            text-align: left; 
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            padding: 20px;
            padding-right: 10px;
            margin-bottom: 20px;
            /* Ëá™ÂÆö‰πâÊªöÂä®Êù°Ê†∑Âºè */
            scrollbar-width: thin;
            scrollbar-color: rgba(212, 175, 55, 0.5) rgba(0, 0, 0, 0.3);
        }
        #reading-text::-webkit-scrollbar {
            width: 8px;
        }
        #reading-text::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        #reading-text::-webkit-scrollbar-thumb {
            background: rgba(212, 175, 55, 0.5);
            border-radius: 4px;
        }
        #reading-text::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 175, 55, 0.7);
        }
        #restart-btn { 
            margin-top: 20px; 
            opacity: 0; 
            flex-shrink: 0;
        }

        /* Ë∞ÉËØï‰∏éËæÖÂä© */
        #input-video { position: absolute; bottom: 10px; right: 10px; width: 100px; height: 75px; transform: scaleX(-1); opacity: 0; z-index: 0; transition: opacity 0.5s; border: 1px solid #333; }
        #input-video.active { opacity: 0.2; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #444; font-size: 12px; letter-spacing: 2px; z-index: 100; transition: opacity 0.5s; }
        .lil-gui { top: auto !important; bottom: 20px !important; right: 20px !important; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...</div>

    <div id="canvas-container"></div>
    <video id="input-video" playsinline></video>

    <!-- Èò∂ÊÆµ1ÔºöÊèêÈóÆ -->
    <div id="intro-layer">
        <div class="intro-text">
            Âú®ÂøÉÈáåÊÉ≥‰∏Ä‰∏™ÈóÆÈ¢ò<br>
            <span style="font-size:12px; color:#666; display:block; margin-top:10px;">ÊàñËÄÖÊääÂÆÉÁïôÂú®ËøôÈáå...</span>
        </div>
        <input type="text" id="user-question" class="soul-input" placeholder="ÔºàÊ≠§Â§ÑÁïôÁôΩ‰∫¶ÂèØÔºâ" autocomplete="off">
        <button id="start-btn" class="start-btn">ÂáùËßÜÊòüÁ©∫</button>
    </div>

    <!-- Èò∂ÊÆµ2ÔºöÊäΩÁâå -->
    <div id="ui-layer">
        <div id="history-bar"></div>
        <div id="status-bar">
            <div id="st-browse" class="status-item"><div class="status-icon">üñê</div><div class="status-label">ÊÑüÂ∫î</div></div>
            <div id="st-grab" class="status-item"><div class="status-icon">‚úä</div><div class="status-label">ÊçïËé∑</div></div>
            <div id="st-release" class="status-item"><div class="status-icon">üñê</div><div class="status-label">ÂΩí‰Ωç</div></div>
        </div>
        <div id="card-detail">
            <div id="card-name"></div><div id="card-sub"></div><div id="card-desc"></div>
            <div id="burn-hint">ÂÜçÊ¨°Âº†ÂºÄÊâãÊéåÔºåÊé•Á∫≥ÊåáÂºï...</div>
        </div>
    </div>

    <!-- Èò∂ÊÆµ3ÔºöËß£ËØª -->
    <div id="reading-layer">
        <div id="reading-content">
            <div id="reading-title">‚ú¶ ÂêØ Á§∫ ‚ú¶</div>
            <div id="reading-text"></div>
            <button id="restart-btn" class="start-btn" onclick="location.reload()">ÈáçÊñ∞ÊèêÈóÆ</button>
        </div>
    </div>

<script>
const CONFIG = { spreadRadius: 22, spreadWidth: 3.5, scrollSpeed: 0.08, cursorSmooth: 0.15, cameraZ: 6.5 };
const AURA_PARAMS = { count: 3000, radiusX: 1.2, radiusY: 1.8, width: 0.3, size: 0.04, color: '#ffffff', speed: 0.02, opacity: 0.8 };

// DeepSeek API ÈÖçÁΩÆ
// ÊñπÂºè1Ôºö‰ΩøÁî®ÂêéÁ´Ø‰ª£ÁêÜÔºàÊé®ËçêÔºåÊõ¥ÂÆâÂÖ®Ôºâ
const DEEPSEEK_CONFIG = {
    useProxy: true, // ËÆæÁΩÆ‰∏∫ true ‰ΩøÁî®ÂêéÁ´Ø‰ª£ÁêÜÔºåfalse Áõ¥Êé•Ë∞ÉÁî® API
    proxyURL: 'http://localhost:3001/api/tarot-reading', // ÂêéÁ´Ø‰ª£ÁêÜÂú∞ÂùÄ
    // ÊñπÂºè2ÔºöÁõ¥Êé•Ë∞ÉÁî® APIÔºà‰∏çÊé®ËçêÔºå‰ºöÊö¥Èú≤ API KeyÔºâ
    apiKey: '', // ‰ªÖÂú® useProxy=false Êó∂‰ΩøÁî®
    baseURL: 'https://api.deepseek.com/v1/chat/completions',
    model: 'deepseek-reasoner' 
};

const MAJORS_INFO = [
    { n: "ÊÑöËÄÖ", e: "The Fool", m: "Êñ∞ÁöÑÂºÄÂßã ¬∑ ÂÜíÈô© ¬∑ Á∫ØÁúü" }, { n: "È≠îÊúØÂ∏à", e: "The Magician", m: "ÂàõÈÄ†Âäõ ¬∑ ÊÑèÂøó ¬∑ ÊòæÂåñ" }, { n: "Â•≥Á•≠Âè∏", e: "The High Priestess", m: "Áõ¥Ëßâ ¬∑ Á•ûÁßò ¬∑ ÊΩúÊÑèËØÜ" }, { n: "ÁöáÂêé", e: "The Empress", m: "‰∏∞È•∂ ¬∑ Ëá™ÁÑ∂ ¬∑ ÊØçÊÄß" }, { n: "ÁöáÂ∏ù", e: "The Emperor", m: "ÊùÉÂ®Å ¬∑ ÁªìÊûÑ ¬∑ ÊéßÂà∂" }, { n: "ÊïôÁöá", e: "The Hierophant", m: "‰º†Áªü ¬∑ ‰ø°‰ª∞ ¬∑ ÊïôËÇ≤" }, { n: "ÊÅã‰∫∫", e: "The Lovers", m: "Áà± ¬∑ ÂíåË∞ê ¬∑ ÈÄâÊã©" }, { n: "ÊàòËΩ¶", e: "The Chariot", m: "ËÉúÂà© ¬∑ ÊÑèÂøó ¬∑ Ëá™Âæã" }, { n: "ÂäõÈáè", e: "Strength", m: "ÂãáÊ∞î ¬∑ ËÄêÂøÉ ¬∑ ÂêåÊÉÖ" }, { n: "ÈöêÂ£´", e: "The Hermit", m: "ÂÜÖÁúÅ ¬∑ Â≠§Áã¨ ¬∑ ÊåáÂºï" }, { n: "ÂëΩËøê‰πãËΩÆ", e: "Wheel of Fortune", m: "Âë®Êúü ¬∑ ÂèòÂåñ ¬∑ ËøêÊ∞î" }, { n: "Ê≠£‰πâ", e: "Justice", m: "ÂÖ¨Âπ≥ ¬∑ ÁúüÁêÜ ¬∑ Âõ†Êûú" }, { n: "ÂÄíÂêä‰∫∫", e: "The Hanged Man", m: "Áâ∫Áâ≤ ¬∑ Êñ∞ËßÜËßí ¬∑ ÊîæÊâã" }, { n: "Ê≠ªÁ•û", e: "Death", m: "ÁªìÊùü ¬∑ ËΩ¨Âèò ¬∑ ÈáçÁîü" }, { n: "ËäÇÂà∂", e: "Temperance", m: "Âπ≥Ë°° ¬∑ ÈÄÇÂ∫¶ ¬∑ ËûçÂêà" }, { n: "ÊÅ∂È≠î", e: "The Devil", m: "ÊùüÁºö ¬∑ Ê¨≤Êúõ ¬∑ ËØ±ÊÉë" }, { n: "È´òÂ°î", e: "The Tower", m: "Á™ÅÂèò ¬∑ Ê∑∑‰π± ¬∑ ËßâÈÜí" }, { n: "ÊòüÊòü", e: "The Star", m: "Â∏åÊúõ ¬∑ ÁÅµÊÑü ¬∑ Ê≤ªÊÑà" }, { n: "Êúà‰∫Æ", e: "The Moon", m: "ÂπªËßâ ¬∑ ‰∏çÂÆâ ¬∑ ÊΩúÊÑèËØÜ" }, { n: "Â§™Èò≥", e: "The Sun", m: "Âø´‰πê ¬∑ ÊàêÂäü ¬∑ Ê¥ªÂäõ" }, { n: "ÂÆ°Âà§", e: "Judgement", m: "Â§çÊ¥ª ¬∑ ËßâÈÜí ¬∑ Âè¨Âî§" }, { n: "‰∏ñÁïå", e: "The World", m: "ÂÆåÊàê ¬∑ Êï¥Âêà ¬∑ ÂúÜÊª°" }
];
const MINORS_SUITS = [ { id: 'wands', name: 'ÊùÉÊùñ', key: 'ÁÅ´' }, { id: 'cups', name: 'Âú£ÊùØ', key: 'Ê∞¥' }, { id: 'swords', name: 'ÂÆùÂâë', key: 'È£é' }, { id: 'pentacles', name: 'ÊòüÂ∏Å', key: 'Âúü' } ];
const MINORS_RANKS = [ { id: 'ace', cn: 'È¶ñÁâå', m: 'Êñ∞ÂºÄÁ´Ø' }, { id: '2', cn: '2', m: 'Âπ≥Ë°°‰∏éÂÜ≥ÂÆö' }, { id: '3', cn: '3', m: 'Âêà‰Ωú' }, { id: '4', cn: '4', m: 'Á®≥ÂÆö' }, { id: '5', cn: '5', m: 'ÂÜ≤Á™Å' }, { id: '6', cn: '6', m: 'ËÉúÂà©' }, { id: '7', cn: '7', m: 'ÂùöÊåÅ' }, { id: '8', cn: '8', m: 'ÂèòÂåñ' }, { id: '9', cn: '9', m: 'ÈüßÊÄß' }, { id: '10', cn: '10', m: 'ÂúÜÊª°' }, { id: 'page', cn: '‰æç‰ªé', m: 'Â•ΩÂ•á' }, { id: 'knight', cn: 'È™ëÂ£´', m: 'Ë°åÂä®' }, { id: 'queen', cn: 'ÁéãÂêé', m: 'ÁêÜËß£' }, { id: 'king', cn: 'ÂõΩÁéã', m: 'ÊéåÊéß' } ];

let RAW_DECK = [];
MAJORS_INFO.forEach((info, index) => { RAW_DECK.push({ ...info, type: 'Major Arcana', url: `major_${index}.jpg` }); });
MINORS_SUITS.forEach(suit => { MINORS_RANKS.forEach(rank => { RAW_DECK.push({ n: `${suit.name}${rank.cn}`, e: `${rank.cn} of ${suit.name}`, m: `${suit.key} ¬∑ ${rank.m}`, type: 'Minor Arcana', url: `${suit.id}_${rank.id}.jpg` }); }); });

/**
 * Fisher-Yates Ê¥óÁâåÁÆóÊ≥ï
 * Áî®‰∫éÈöèÊú∫ÂåñÁâåÁªÑÁöÑÈ°∫Â∫è
 */
function shuffleDeck(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

/**
 * ÊåâÁÖßÂ°îÁΩóËßÑÂàôÂàõÂª∫Âπ∂Ê¥óÁâå
 * Ê®°ÊãüÁúüÂÆûÂ°îÁΩóÂÆûË∑µÔºöÂú®Ê¥óÁâåËøáÁ®ã‰∏≠ÁøªËΩ¨‰∏Ä‰∫õÁâå
 * - ‰ΩøÁî®30%-60%‰πãÈó¥ÁöÑÈÄÜ‰ΩçÁéáÔºàÊØèËΩÆÂèØÂèòÂåñÔºåÂàõÈÄ†"ÂëΩËøêÊ∞õÂõ¥"Ôºâ
 * - Ê¥óÁâåÂÆåÊàêÂêéÔºåÊØèÂº†ÁâåÁöÑÊñπÂêëÂõ∫ÂÆöÔºåÊäΩÁâåÊó∂‰∏çÂÜçÈöèÊú∫
 */
function createTarotDeck(rawDeck) {
    // 1. ÂÖàÊ¥óÁâåÔºåÈöèÊú∫ÂåñÁâåÁöÑÈ°∫Â∫èÔºàFisher-YatesÁÆóÊ≥ïÔºâ
    const shuffled = shuffleDeck(rawDeck);
    
    // 2. Á°ÆÂÆöÊú¨ËΩÆÊ¥óÁâåÁöÑÈÄÜ‰ΩçÁéáÔºà30%-60%‰πãÈó¥ÔºåÂàõÈÄ†"ÂëΩËøêÊ∞õÂõ¥"Ôºâ
    // ÊØèËΩÆÊ∏∏ÊàèÂèØËÉΩ‰∏çÂêåÁöÑÈÄÜ‰ΩçÁéáÔºåËÆ©Êüê‰∫õËΩÆËá™ÁÑ∂ÂåÖÂê´Êõ¥Â§öÈÄÜ‰ΩçÁâå
    const reversedRate = 0.3 + Math.random() * 0.3; // 0.3 Âà∞ 0.6 ‰πãÈó¥
    
    // 3. ‰∏∫ÊØèÂº†ÁâåÂàÜÈÖçÂõ∫ÂÆöÁöÑÊñπÂêëÔºàÂú®Ê¥óÁâåÈò∂ÊÆµÁ°ÆÂÆöÔºåËÄå‰∏çÊòØÊäΩÁâåÊó∂Ôºâ
    // Ê®°ÊãüÊ¥óÁâåËøáÁ®ã‰∏≠Êüê‰∫õÁâåË¢´ÁøªËΩ¨ÁöÑÊÉÖÂÜµ
    const deck = shuffled.map(card => ({
        ...card,
        isReversed: Math.random() < reversedRate // Ê†πÊçÆÈÄÜ‰ΩçÁéáÂÜ≥ÂÆöÊòØÂê¶ÈÄÜ‰Ωç
    }));
    
    // 4. ÊñπÂêëÂ∑≤Âõ∫ÂÆöÔºåËøîÂõûÊ¥óÂ•ΩÁöÑÁâåÁªÑ
    return deck;
}

const getImg = (path) => path.startsWith('http') ? path : `assets/${path}`; 

/* SHADERS */
const ashVertexShader = `uniform float uTime; uniform float uSpeed; uniform float uSize; uniform float uSpread; attribute float aRandom; attribute vec3 aColor; varying vec3 vColor; varying float vAlpha; vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;} float snoise(vec3 v){ const vec2 C=vec2(1.0/6.0,1.0/3.0); const vec4 D=vec4(0.0,0.5,1.0,2.0); vec3 i=floor(v+dot(v,C.yyy)); vec3 x0=v-i+dot(i,C.xxx); vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g; vec3 i1=min(g.xyz,l.zxy); vec3 i2=max(g.xyz,l.zxy); vec3 x1=x0-i1+C.xxx; vec3 x2=x0-i2+C.yyy; vec3 x3=x0-D.yyy; i=mod289(i); vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0)); float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx; vec4 j=p-49.0*floor(p*ns.z*ns.z); vec4 x_=floor(j*ns.z); vec4 y_=floor(j-7.0*x_); vec4 x=x_*ns.x+ns.yyyy; vec4 y=y_*ns.x+ns.yyyy; vec4 h=1.0-abs(x)-abs(y); vec4 b0=vec4(x.xy,y.xy); vec4 b1=vec4(x.zw,y.zw); vec4 s0=floor(b0)*2.0+1.0; vec4 s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0)); vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw+s1.xzyw*sh.zzww; vec3 p0=vec3(a0.xy,h.x); vec3 p1=vec3(a0.zw,h.y); vec3 p2=vec3(a1.xy,h.z); vec3 p3=vec3(a1.zw,h.w); vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w; vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m=m*m; return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3))); } void main() { vColor = aColor; float t = uTime * (1.0 + aRandom * 0.5); vec3 noisePos = position * 0.5 + vec3(0.0, t * 0.5, 0.0); float noiseVal = snoise(noisePos); vec3 newPos = position; newPos.y += t * 2.0; newPos.x += noiseVal * t * uSpread; newPos.z += noiseVal * t * uSpread; vAlpha = 1.0 - smoothstep(0.0, 2.5, t); vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0); gl_PointSize = (uSize * aRandom + 2.0) * (1.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
const ashFragmentShader = `varying vec3 vColor; varying float vAlpha; void main() { if (vAlpha <= 0.0) discard; vec2 coord = gl_PointCoord - vec2(0.5); float dist = length(coord); if(dist > 0.5) discard; float glow = 1.0 - (dist * 2.0); gl_FragColor = vec4(vColor, vAlpha * glow); }`;
const auraVertexShader = `uniform float uTime; uniform float uSize; attribute float aRandom; attribute float aAngle; attribute float aRadius; varying float vAlpha; void main() { vec3 newPos = position; float twinkle = 0.5 + 0.5 * sin(uTime * 2.0 + aRandom * 10.0); vAlpha = twinkle; vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0); gl_PointSize = (uSize * aRandom + 10.0) * (1.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
const auraFragmentShader = `uniform vec3 uColor; uniform float uOpacity; varying float vAlpha; void main() { vec2 coord = gl_PointCoord - vec2(0.5); float dist = length(coord); if(dist > 0.5) discard; float strength = 1.0 - (dist * 2.0); strength = pow(strength, 2.0); gl_FragColor = vec4(uColor, vAlpha * uOpacity * strength); }`;

class TarotSpace {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.w = window.innerWidth; this.h = window.innerHeight;
        this.cards = []; this.particles = [];
        
        // Ê∏∏ÊàèÁä∂ÊÄÅÁÆ°ÁêÜ
        this.gameState = 'intro'; // intro -> playing -> reading
        this.gestureState = 'browsing'; // playingÁä∂ÊÄÅ‰∏ãÁöÑÂ≠êÁä∂ÊÄÅ: browsing, revealed
        this.gestureMode = 'none'; 
        
        this.drawnCards = []; // Â∑≤ÊäΩÂèñÁöÑÁâå
        this.maxCards = 3;
        
        // ÊåâÁÖßÂ°îÁΩóËßÑÂàôÂàõÂª∫Âπ∂Ê¥óÁâåÔºàÊØèÊ¨°ÂàùÂßãÂåñÊó∂ËøõË°å‰∏ÄÊ¨°ÔºåÊñπÂêëÂõ∫ÂÆöÔºâ
        this.tarotDeck = createTarotDeck(RAW_DECK);
        
        this.scrollOffset = 0; this.targetScrollOffset = 0;
        this.hoveredCard = null; this.revealedCard = null;
        this.handPos = { x: 0, y: 0 };
        this.cursorPos = new THREE.Vector2(0,0);
        this.targetCursorPos = new THREE.Vector2(0,0);
        
        this.texLoader = new THREE.TextureLoader();
        this.texLoader.setCrossOrigin('anonymous');
        
        this.initThree();
        this.backTexture = this.generateCardTexture(); 
        this.loadLocalBack(); 

        this.initCards(); // ÂàùÂßãÂåñÊó∂‰∏çÊòæÁ§∫ÔºåÁ≠âÂæÖ start
        this.initCursor(); 
        this.initAura();   
        this.initBackgroundStars();
        this.initMediaPipe();
        this.initMouse();
        this.initDOM(); // ÁªëÂÆöDOM‰∫ã‰ª∂

        this.animate();
        
        // Âä†ËΩΩÂÆåÊàê
        document.getElementById('loading').style.display = 'none';
    }

    initDOM() {
        const startBtn = document.getElementById('start-btn');
        const userQ = document.getElementById('user-question');
        
        startBtn.addEventListener('click', () => {
            const question = userQ.value.trim();
            console.log("User Question:", question || "Silent contemplation");
            this.startSession();
        });
    }

    startSession() {
        // 1. UI ÂàáÊç¢
        const intro = document.getElementById('intro-layer');
        intro.classList.add('fade-exit');
        
        const ui = document.getElementById('ui-layer');
        ui.classList.add('active'); // ÂÖÅËÆ∏ pointer-events

        // 2. Áä∂ÊÄÅÂàáÊç¢
        this.gameState = 'playing';
        this.gestureState = 'browsing';

        // 3. Âç°ÁâåÂÖ•Âú∫Âä®Áîª (Ê®°ÊãüÊ¥óÁâå)
        this.cards.forEach((group, i) => {
            group.position.set(0, 0, -50); // ÂÖàÊîæËøú
            group.visible = true;
            
            // ÈöèÊú∫Âª∂ËøüÈ£ûÂÖ•
            new TWEEN.Tween(group.position)
                .to({ z: -5 }, 1500)
                .delay(i * 10) // ÈîôËêΩÊúâËá¥
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        });
    }

    async finishSession() {
        this.gameState = 'reading';
        
        const readingLayer = document.getElementById('reading-layer');
        const readingText = document.getElementById('reading-text');
        
        readingLayer.style.display = 'flex';
        void readingLayer.offsetWidth; 
        readingLayer.style.opacity = 1;

        const question = document.getElementById('user-question').value || "Êó†Â£∞ÁöÑÂõ∞ÊÉë";
        const cardsStr = this.drawnCards.map(c => 
            `${c.name}${c.isReversed ? '(ÈÄÜ‰Ωç)' : '(Ê≠£‰Ωç)'}`
        ).join(' ‚Üí ');

        // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
        readingText.textContent = 'ÊòüËæ∞Ê≠£Âú®Ê±áËÅö...\n\nËØ∑Á®çÂÄôÔºåÂëΩËøê‰πãËΩÆÊ≠£Âú®ËΩ¨Âä®...';

        try {
            // Ë∞ÉÁî® DeepSeek API
            const interpretation = await this.callDeepSeekAPI(question, this.drawnCards);
            this.displayReading(readingText, question, cardsStr, interpretation);
        } catch (error) {
            console.error('DeepSeek API Ë∞ÉÁî®Â§±Ë¥•:', error);
            // Â¶ÇÊûú API Ë∞ÉÁî®Â§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÊñáÊú¨
            const fallbackText = `‰Ω†ÁöÑÈóÆÈ¢òÔºö${question}\n\nÁâåÈòµÊåáÂºïÔºö\n${cardsStr}\n\n‚ö†Ô∏è API Ë∞ÉÁî®Â§±Ë¥•: ${error.message}\n\nËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•Âíå API Key ÈÖçÁΩÆ„ÄÇ\n\nÊòüËæ∞‰ΩéËØ≠Ôºö\nÂëΩËøê‰∏çÊòØÊó¢ÂÆöÁöÑËΩ®ÈÅìÔºåËÄåÊòØÂΩì‰∏ãÁöÑÈÄâÊã©„ÄÇËøô‰∏âÂº†ÁâåÂàÜÂà´‰ª£Ë°®‰∫Ü‰Ω†ÂΩì‰∏ãÁöÑÂ§ÑÂ¢É„ÄÅÈù¢‰∏¥ÁöÑÊåëÊàò‰ª•ÂèäÂèØËÉΩÁöÑÊåáÂºï...`;
            this.displayReading(readingText, question, cardsStr, fallbackText);
        }
    }

    async callDeepSeekAPI(question, cards) {
        // ‰ΩøÁî®ÂêéÁ´Ø‰ª£ÁêÜÔºàÊé®ËçêÊñπÂºèÔºâ
        if (DEEPSEEK_CONFIG.useProxy) {
            const response = await fetch(DEEPSEEK_CONFIG.proxyURL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question: question,
                    cards: cards,
                    model: DEEPSEEK_CONFIG.model
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `‰ª£ÁêÜËØ∑Ê±ÇÂ§±Ë¥•: ${response.status}`);
            }

            const data = await response.json();
            return data.choices[0]?.message?.content || 'Êú™ËÉΩËé∑ÂèñËß£ËØªÂÜÖÂÆπ';
        }
        
        // Áõ¥Êé•Ë∞ÉÁî® APIÔºà‰∏çÊé®ËçêÔºå‰ºöÊö¥Èú≤ API KeyÔºâ
        if (!DEEPSEEK_CONFIG.apiKey) {
            throw new Error('API Key Êú™ÈÖçÁΩÆÔºåËØ∑ËÆæÁΩÆ DEEPSEEK_CONFIG.apiKey Êàñ‰ΩøÁî®ÂêéÁ´Ø‰ª£ÁêÜÔºàËÆæÁΩÆ useProxy: trueÔºâ');
        }

        const cardsDescription = cards.map((c, index) => {
            const position = ['ËøáÂéª/Áé∞Áä∂', 'Áé∞Âú®/ÊåëÊàò', 'Êú™Êù•/ÊåáÂºï'][index] || 'Êú™Áü•';
            return `${position}: ${c.name}${c.isReversed ? '(ÈÄÜ‰Ωç)' : '(Ê≠£‰Ωç)'}`;
        }).join('\n');

        const systemPrompt = `‰Ω†ÊòØ‰∏Ä‰ΩçËµÑÊ∑±ÁöÑÂ°îÁΩóÁâåËß£ËØªÂ∏àÔºåÊìÖÈïøÁî®ËØóÊÑèËÄåÊ∑±ÂàªÁöÑËØ≠Ë®ÄËß£ËØªÂ°îÁΩóÁâåÁöÑÂê´‰πâ„ÄÇËØ∑Ê†πÊçÆÁî®Êà∑ÁöÑÈóÆÈ¢òÂíå‰∏âÂº†Â°îÁΩóÁâåÔºåÊèê‰æõ‰∏Ä‰ªΩÊ∑±ÂàªËÄåÊúâÂêØÂèëÊÄßÁöÑËß£ËØª„ÄÇ`;
        const userPrompt = `ÈóÆÈ¢òÔºö${question}\n\nÊäΩÂà∞ÁöÑ‰∏âÂº†ÁâåÔºö\n${cardsDescription}\n\nËØ∑Êèê‰æõ‰∏Ä‰ªΩËØ¶ÁªÜÁöÑÂ°îÁΩóÁâåËß£ËØªÔºåÂåÖÊã¨Ôºö\n1. ÂØπÈóÆÈ¢òÁöÑÊï¥‰ΩìÂàÜÊûê\n2. ÊØèÂº†ÁâåÁöÑÂê´‰πâÂèäÂÖ∂Âú®ÈóÆÈ¢ò‰∏≠ÁöÑÊÑè‰πâ\n3. ‰∏âÂº†Áâå‰πãÈó¥ÁöÑÂÖ≥ËÅîÂíåÊï¥‰ΩìÊåáÂºï\n4. Áªô‰∫àÂª∫ËÆÆÊàñÂêØÁ§∫\n\nËØ∑Áî®‰ºòÈõÖ„ÄÅÂØåÊúâËØóÊÑèÁöÑ‰∏≠ÊñáÂõûÁ≠îÔºåËØ≠Ë®ÄË¶ÅÊúâÁ•ûÁßòÊÑüÂíåÂêØÂèëÊÄß„ÄÇ`;

        const response = await fetch(DEEPSEEK_CONFIG.baseURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`
            },
            body: JSON.stringify({
                model: DEEPSEEK_CONFIG.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: 0.8,
                max_tokens: 2000
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`API ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${errorData.error?.message || response.statusText}`);
        }

        const data = await response.json();
        return data.choices[0]?.message?.content || 'Êú™ËÉΩËé∑ÂèñËß£ËØªÂÜÖÂÆπ';
    }

    displayReading(readingTextElement, question, cardsStr, interpretation) {
        const fullText = `‰Ω†ÁöÑÈóÆÈ¢òÔºö${question}\n\nÁâåÈòµÊåáÂºïÔºö\n${cardsStr}\n\n${'‚îÄ'.repeat(40)}\n\n${interpretation}`;
        
        // ÊâìÂ≠óÊú∫ÊïàÊûú
        readingTextElement.textContent = '';
        let i = 0;
        const typeWriter = setInterval(() => {
            readingTextElement.textContent += fullText.charAt(i);
            i++;
            if (i >= fullText.length) {
                clearInterval(typeWriter);
                // ÊòæÁ§∫ÈáçÂºÄÊåâÈíÆ
                new TWEEN.Tween(document.getElementById('restart-btn').style)
                    .to({ opacity: 1 }, 1000).start();
            }
        }, 30);
    }

    // ... (generateMagicCursorTexture, generateCardTexture, loadLocalBack, createFrontTexture, initThree, initBackgroundStars, initAura, updateAura ‰øùÊåÅ‰∏çÂèò)
    generateMagicCursorTexture() {
        const c = document.createElement('canvas'); c.width = 256; c.height = 256; const ctx = c.getContext('2d');
        const cx = 128, cy = 128; ctx.strokeStyle = '#d4af37'; ctx.shadowBlur = 10; ctx.shadowColor = '#d4af37';
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, 100, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(cx, cy, 90, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); for(let i=0; i<3; i++) { const a = (i * 120) * Math.PI/180; const x = cx + Math.cos(a)*90; const y = cy + Math.sin(a)*90; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.stroke();
        ctx.beginPath(); for(let i=0; i<3; i++) { const a = (i * 120 + 60) * Math.PI/180; const x = cx + Math.cos(a)*90; const y = cy + Math.sin(a)*90; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.stroke();
        ctx.font = '20px serif'; ctx.fillStyle = '#d4af37'; ctx.textAlign='center'; ctx.fillText('‚ö°', cx, cy+8);
        return new THREE.CanvasTexture(c);
    }
    generateCardTexture() { const c = document.createElement('canvas'); c.width = 256; c.height = 400; const ctx = c.getContext('2d'); ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,256,400); ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10; ctx.strokeRect(10,10,236,380); ctx.beginPath(); ctx.arc(128, 200, 60, 0, Math.PI*2); ctx.stroke(); return new THREE.CanvasTexture(c); }
    loadLocalBack() { this.texLoader.load('tarot-card-back.jpg', (tex) => { this.backTexture = tex; this.cards.forEach(group => { group.children[0].material.map = tex; group.children[0].material.needsUpdate = true; }); }, undefined, (err) => console.warn("Êú™ÊâæÂà∞ÁâåËÉåÂõæÁâá")); }
    createFrontTexture(data) { const c = document.createElement('canvas'); c.width = 512; c.height = 800; const ctx = c.getContext('2d'); ctx.fillStyle = '#f5f0e1'; ctx.fillRect(0,0,512,800); ctx.strokeStyle = '#333'; ctx.lineWidth = 15; ctx.strokeRect(20,20,472,760); ctx.fillStyle = '#111'; ctx.textAlign = 'center'; ctx.font = 'bold 50px serif'; ctx.fillText(data.e, 256, 300); ctx.font = '30px sans-serif'; ctx.fillStyle = '#555'; ctx.fillText(data.n, 256, 360); return new THREE.CanvasTexture(c); }
    initThree() { this.scene = new THREE.Scene(); this.camera = new THREE.PerspectiveCamera(60, this.w/this.h, 0.1, 100); this.camera.position.set(0, 0, CONFIG.cameraZ); this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); this.renderer.setSize(this.w, this.h); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.outputEncoding = THREE.LinearEncoding; this.container.appendChild(this.renderer.domElement); this.scene.add(new THREE.AmbientLight(0xffffff, 1.0)); }
    initBackgroundStars() { const count = 1500; const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<count; i++) pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*80-40); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({ color: 0x888888, size: 2, sizeAttenuation: false, transparent: true, opacity: 0.8 }); this.bgStars = new THREE.Points(geo, mat); this.scene.add(this.bgStars); }
    initAura() { const pCount = AURA_PARAMS.count; const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<pCount; i++) { const th = Math.random() * Math.PI * 2; const rx = AURA_PARAMS.radiusX + Math.random() * AURA_PARAMS.width; const ry = AURA_PARAMS.radiusY + Math.random() * AURA_PARAMS.width; pos.push(Math.cos(th)*rx, Math.sin(th)*ry, (Math.random()-0.5)*0.5); } geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({ color: AURA_PARAMS.color, size: AURA_PARAMS.size, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false }); this.aura = new THREE.Points(geo, mat); this.scene.add(this.aura); }
    updateAura() { if(!this.aura) return; this.aura.rotation.z += AURA_PARAMS.speed; if (this.gestureState === 'browsing' && this.hoveredCard) { this.aura.position.copy(this.hoveredCard.position); this.aura.position.z += AURA_PARAMS.zOffset; this.aura.rotation.y = this.hoveredCard.rotation.y; this.aura.material.opacity += (AURA_PARAMS.opacity - this.aura.material.opacity) * 0.1; } else { this.aura.material.opacity += (0 - this.aura.material.opacity) * 0.2; } }
    initCursor() { const tex = this.generateMagicCursorTexture(); this.cursorMesh = new THREE.Mesh( new THREE.PlaneGeometry(0.6, 0.6), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.8, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthTest: false }) ); this.cursorMesh.visible = false; this.scene.add(this.cursorMesh); this.raycaster = new THREE.Raycaster(); }

    initCards() {
        const geo = new THREE.PlaneGeometry(2.0, 3.2);
        const count = this.tarotDeck.length;
        const backMat = new THREE.MeshBasicMaterial({ map: this.backTexture, color: 0xffffff, side: THREE.FrontSide });
        const frontMat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.FrontSide });

        for (let i = 0; i < count; i++) {
            const group = new THREE.Group();
            const back = new THREE.Mesh(geo, backMat); back.position.z = 0.01; back.rotation.y = 0;
            const front = new THREE.Mesh(geo, frontMat); front.position.z = -0.01; front.rotation.y = Math.PI;
            group.add(back); group.add(front);
            
            // ÂàùÂßãÂú®Â±èÂπïÂ§ñÔºåvisible false
            group.visible = false;
            group.userData = { id: i, info: this.tarotDeck[i], baseX: (i - count/2) * CONFIG.spreadWidth };
            this.scene.add(group);
            this.cards.push(group);
        }
    }

    updateLayout() {
        if (this.gameState !== 'playing') return; // Âè™Âú®Ê∏∏ÊàèÈò∂ÊÆµÊõ¥Êñ∞
        if (this.gestureState === 'revealed' || this.gestureState === 'burning') return;
        
        this.scrollOffset += (this.targetScrollOffset - this.scrollOffset) * 0.1;
        if(this.cursorMesh.visible) this.cursorMesh.rotation.z -= 0.02;

        this.cards.forEach((card) => {
            const worldX = card.userData.baseX + this.scrollOffset;
            const dist = Math.abs(worldX);
            if (dist > 8.0) { card.visible = false; return; }
            card.visible = true;

            card.position.x = worldX;
            card.position.z = -Math.pow(dist * 0.25, 1.5);
            card.rotation.y = Math.max(-0.5, Math.min(0.5, -worldX * 0.06));

            if (this.gestureState === 'browsing' && this.hoveredCard === card) {
                card.scale.setScalar(1.1); card.position.z += 1.5; card.rotation.y = 0;
            } else {
                card.scale.setScalar(1.0);
            }
        });
    }

    handleGestures() {
        if (this.gameState !== 'playing') return;
        if (this.gestureState === 'burning') return;
        
        ['st-browse', 'st-grab', 'st-release'].forEach(id => document.getElementById(id).classList.remove('active'));

        if (this.gestureState === 'browsing') {
            if (this.gestureMode === 'open') {
                document.getElementById('st-browse').classList.add('active');
                if (Math.abs(this.handPos.x) > 0.3) {
                    const speed = CONFIG.scrollSpeed;
                    if (this.handPos.x < 0) this.targetScrollOffset += speed * (Math.abs(this.handPos.x)*1.5);
                    else this.targetScrollOffset -= speed * (Math.abs(this.handPos.x)*1.5);
                    
                    const limit = (this.cards.length/2)*CONFIG.spreadWidth + 2;
                    this.targetScrollOffset = Math.max(-limit, Math.min(limit, this.targetScrollOffset));
                    this.cursorMesh.visible = false; this.hoveredCard = null;
                } else {
                    this.cursorMesh.visible = true;
                    this.cursorPos.lerp(this.targetCursorPos, CONFIG.cursorSmooth);
                    const vec = new THREE.Vector3(this.cursorPos.x, this.cursorPos.y, 0.5); vec.unproject(this.camera);
                    const dir = vec.sub(this.camera.position).normalize();
                    const pos = this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z/dir.z));
                    this.cursorMesh.position.copy(pos);
                    
                    this.raycaster.setFromCamera(this.cursorPos, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.cards.filter(c => c.visible), true);
                    if (intersects.length > 0) {
                        let target = intersects[0].object; while(target.parent && !target.userData.id) target = target.parent;
                        this.hoveredCard = target;
                    } else this.hoveredCard = null;
                }
            } 
            else if (this.gestureMode === 'fist') {
                document.getElementById('st-grab').classList.add('active');
                if (this.hoveredCard) this.revealCard(this.hoveredCard);
            }
        } 
        else if (this.gestureState === 'revealed') {
            document.getElementById('st-release').classList.add('active');
            if (this.gestureMode === 'open') {
                this.burnCard();
            }
        }
    }

    revealCard(cardGroup) {
        if (this.gestureState === 'revealed') return;
        this.gestureState = 'revealed'; 
        this.revealedCard = cardGroup; this.cursorMesh.visible = false;

        document.getElementById('burn-hint').style.display = 'block';

        const data = cardGroup.userData.info;
        const frontMesh = cardGroup.children[1];
        
        frontMesh.material = new THREE.MeshBasicMaterial({ side: THREE.FrontSide, color: 0xffffff });

        // Á´ãÂç≥‰ªéÁâåÂ†Ü‰∏≠ÁßªÈô§ÔºåÈÅøÂÖçÈáçÂ§çÊäΩÂèñ
        const idx = this.cards.indexOf(cardGroup);
        if (idx > -1) {
            this.cards.splice(idx, 1);
            // ÈáçÊñ∞ËÆ°ÁÆóÂâ©‰ΩôÁâåÁöÑ baseX ‰ΩçÁΩÆ
            this.cards.forEach((group, i) => {
                group.userData.baseX = (i - this.cards.length/2) * CONFIG.spreadWidth;
            });
        }

        this.texLoader.load(getImg(data.url), (tex) => { 
            frontMesh.material.map = tex; frontMesh.material.needsUpdate = true; 
            // Â≠òÂÖ•Êï∞ÊçÆÔºå‰ΩÜ‰∏çÁ´ãÂç≥ÊòæÁ§∫UIÔºåÁ≠âÂΩí‰Ωç
            this.drawnCards.push({ name: data.n, isReversed: data.isReversed, img: data.url });
        }, undefined, () => { 
            frontMesh.material.map = this.createFrontTexture(data); frontMesh.material.needsUpdate = true; 
            this.drawnCards.push({ name: data.n, isReversed: data.isReversed, img: null });
        });

        const targetRotZ = data.isReversed ? Math.PI : 0;

        new TWEEN.Tween(cardGroup.position).to({ x: 0, y: 0, z: CONFIG.cameraZ - 4 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
        new TWEEN.Tween(cardGroup.rotation).to({ x: 0, y: Math.PI, z: targetRotZ }, 1000).easing(TWEEN.Easing.Back.Out).start();

        this.cards.forEach(c => { new TWEEN.Tween(c.position).to({ z: -50 }, 800).start(); });
        setTimeout(() => {
            const revText = data.isReversed ? " (ÈÄÜ‰Ωç)" : "";
            document.getElementById('card-name').innerText = data.n + revText; 
            document.getElementById('card-sub').innerText = data.e; 
            document.getElementById('card-desc').innerText = data.m; 
            document.getElementById('card-detail').style.opacity = 1;
        }, 800);
    }

    addToHistory(imgUrl, isReversed, cardName) {
        const container = document.getElementById('history-bar');
        const slot = document.createElement('div');
        slot.className = `history-slot ${isReversed ? 'reversed' : ''}`;
        const imgBox = document.createElement('div');
        imgBox.className = 'history-img-box';
        if (imgUrl) { const img = document.createElement('img'); img.src = "assets/" + imgUrl; imgBox.appendChild(img); }
        slot.appendChild(imgBox);
        const textBox = document.createElement('div');
        textBox.className = 'history-text';
        textBox.innerHTML = cardName + (isReversed ? '<br><span class="rev-mark">ÈÄÜ‰Ωç</span>' : '');
        slot.appendChild(textBox);
        container.appendChild(slot);
    }

    burnCard() {
        if (!this.revealedCard || this.gestureState === 'burning') return;
        this.gestureState = 'burning';
        
        // ËøôÈáåÁöÑ‚Äúburn‚ÄùÂÖ∂ÂÆûÊòØÂΩí‰ΩçÈÄªËæë
        this.createAshEffect(this.revealedCard.position);
        
        // È£ûÂêëÂ∑¶‰∏äËßí
        new TWEEN.Tween(this.revealedCard.position)
            .to({ x: -8, y: 5, z: -10 }, 800)
            .easing(TWEEN.Easing.Cubic.In)
            .start();
            
        new TWEEN.Tween(this.revealedCard.scale)
            .to({ x: 0, y: 0, z: 0 }, 800)
            .onComplete(() => {
                this.revealedCard.visible = false; 
                this.scene.remove(this.revealedCard);
                
                // Ê∑ªÂä†Âà∞ UI ÂéÜÂè≤Ê†è
                const lastDrawn = this.drawnCards[this.drawnCards.length - 1];
                this.addToHistory(lastDrawn.img, lastDrawn.isReversed, lastDrawn.name);

                // ÁâåÂ∑≤ÁªèÂú® revealCard() Êó∂‰ªé this.cards ‰∏≠ÁßªÈô§‰∫ÜÔºåËøôÈáåÂè™ÈúÄË¶ÅÊ∏ÖÁêÜÂºïÁî®
                this.revealedCard = null;
                
                // UI ÈáçÁΩÆ
                document.getElementById('card-detail').style.opacity = 0;
                document.getElementById('burn-hint').style.display = 'none';

                // Âà§Êñ≠ÊòØÂê¶ÁªìÊùü
                if (this.drawnCards.length >= this.maxCards) {
                    this.finishSession();
                } else {
                    this.gestureState = 'browsing';
                }
            })
            .start();
    }

    createAshEffect(pos) {
        const count = 3000; const geo = new THREE.BufferGeometry(); const positions = [], randoms = [], colors = []; const color = new THREE.Color(0xd4af37);
        for(let i=0; i<count; i++) { positions.push((Math.random()-0.5)*2.0, (Math.random()-0.5)*3.2, 0); randoms.push(Math.random()); colors.push(color.r, color.g, color.b); }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geo.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1)); geo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.ShaderMaterial({ vertexShader: ashVertexShader, fragmentShader: ashFragmentShader, uniforms: { uTime: { value: 0 }, uSpeed: { value: 1.5 }, uSize: { value: 4.0 }, uSpread: { value: 0.5 } }, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
        const points = new THREE.Points(geo, material); points.position.copy(pos); this.scene.add(points); this.particles.push({ mesh: points, age: 0 });
    }

    initMediaPipe() {
        const vid = document.getElementById('input-video'); const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const idx = lm[8], thb = lm[4], wrs = lm[0], mid = lm[12], rng = lm[16], pnk = lm[20], idx_mcp = lm[5], pnk_mcp = lm[17];
                this.handPos.x = (1 - lm[9].x) * 2 - 1; this.targetCursorPos.x = (1 - idx.x) * 2 - 1; this.targetCursorPos.y = -(idx.y * 2 - 1);
                const dist = (a, b) => Math.sqrt(Math.pow(a.x-b.x,2) + Math.pow(a.y-b.y,2));
                const pinchDist = dist(idx, thb);
                const isFist = dist(idx, wrs)<0.3 && dist(mid, wrs)<0.25 && dist(rng, wrs)<0.25 && dist(pnk, wrs)<0.25;
                const isPinch = pinchDist < 0.05;
                const isOpen = dist(idx, wrs)>0.3 && dist(mid, wrs)>0.3 && dist(rng, wrs)>0.3 && dist(pnk, wrs)>0.3;
                const isPoint = dist(idx, wrs)>0.3 && dist(mid, wrs)<0.25; 
                if (isFist) this.gestureMode = 'fist'; else if (isPinch || isPoint) this.gestureMode = 'point'; else if (isOpen) this.gestureMode = 'open'; else this.gestureMode = 'none';
            } else this.gestureMode = 'none';
        });
        const camera = new Camera(vid, { onFrame: async () => { await hands.send({image: vid}); }, width: 320, height: 240 });
        camera.start();
    }

    initMouse() {
        window.addEventListener('mousemove', e => { const x = (e.clientX/this.w)*2-1; const y = -(e.clientY/this.h)*2+1; this.handPos.x = x; this.targetCursorPos.set(x, y); if (Math.abs(x)>0.4) this.gestureMode='open'; else this.gestureMode='point'; });
        window.addEventListener('mousedown', e => { if(e.button===0) this.gestureMode='fist'; }); 
        window.addEventListener('mouseup', () => { this.gestureMode='open'; }); 
        window.addEventListener('contextmenu', e => e.preventDefault());
    }

    animate() {
        requestAnimationFrame(() => this.animate()); TWEEN.update(); this.updateLayout(); this.updateAura(); this.handleGestures();
        if(this.bgStars) this.bgStars.rotation.y += 0.0002;
        for (let i = this.particles.length - 1; i >= 0; i--) { const p = this.particles[i]; p.age += 0.015; p.mesh.material.uniforms.uTime.value = p.age; if (p.age > 3.0) { this.scene.remove(p.mesh); this.particles.splice(i, 1); } }
        this.renderer.render(this.scene, this.camera);
    }
}
window.onload = () => new TarotSpace();
</script>
</body>
</html>