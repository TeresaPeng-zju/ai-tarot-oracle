<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot Oracle: The Void</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;600&display=swap'); /* å¼•å…¥ä¸­æ–‡å­—ä½“ */

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Cinzel', 'Noto Serif SC', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* é€šç”¨æ·¡å…¥æ·¡å‡ºç±» */
        .fade-enter { opacity: 0; animation: fadeIn 1s forwards; }
        .fade-exit { opacity: 1; animation: fadeOut 1s forwards; pointer-events: none; }
        @keyframes fadeIn { to { opacity: 1; } }
        @keyframes fadeOut { to { opacity: 0; } }

        /* ==================== é˜¶æ®µ1ï¼šæé—®å±‚ (Intro Layer) ==================== */
        #intro-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
        }
        .intro-text {
            color: #ccc; font-size: 18px; letter-spacing: 3px; margin-bottom: 40px;
            text-shadow: 0 0 10px rgba(255,255,255,0.3); text-align: center;
        }
        .soul-input {
            background: transparent; border: none; border-bottom: 1px solid rgba(212, 175, 55, 0.5);
            width: 300px; padding: 10px; color: #d4af37; font-size: 20px; text-align: center;
            font-family: 'Noto Serif SC', serif; outline: none; transition: 0.5s;
        }
        .soul-input:focus { border-bottom: 1px solid #d4af37; width: 400px; }
        .soul-input::placeholder { color: #444; font-style: italic; }
        
        .start-btn {
            margin-top: 60px; padding: 12px 40px; background: transparent;
            border: 1px solid #444; color: #888; font-family: 'Cinzel', serif; letter-spacing: 2px;
            cursor: pointer; transition: 0.5s; border-radius: 2px;
        }
        .start-btn:hover { border-color: #d4af37; color: #d4af37; box-shadow: 0 0 20px rgba(212,175,55,0.2); }

        /* ==================== é˜¶æ®µ2ï¼šæ¸¸æˆUIå±‚ (Play Layer) ==================== */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; 
            pointer-events: none; opacity: 0; transition: opacity 1s;
        }
        #ui-layer.active { opacity: 1; pointer-events: none; } /* inner elements have pointer-events auto */

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #status-bar { 
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 60px; opacity: 0.8;
        }
        .status-item { display: flex; flex-direction: column; align-items: center; gap: 8px; opacity: 0.2; transition: 0.4s; color: #888; }
        .status-icon { font-size: 24px; filter: drop-shadow(0 0 5px rgba(0,0,0,0.5)); }
        .status-label { font-size: 10px; letter-spacing: 2px; text-transform: uppercase; }
        .status-item.active { opacity: 1; color: #d4af37; transform: translateY(-5px); text-shadow: 0 0 15px rgba(212, 175, 55, 0.6); }

        /* å†å²è®°å½• */
        #history-bar { position: absolute; top: 30px; left: 30px; display: flex; gap: 15px; pointer-events: auto; }
        .history-slot { display: flex; flex-direction: column; align-items: center; width: 50px; opacity: 0; animation: fadeSlideIn 0.8s forwards; }
        @keyframes fadeSlideIn { from { opacity:0; transform:translateY(-20px); } to { opacity:1; transform:translateY(0); } }
        .history-img-box {
            width: 36px; height: 60px; border: 1px solid rgba(212, 175, 55, 0.4);
            box-shadow: 0 0 10px rgba(0,0,0,0.8); border-radius: 2px; overflow: hidden; margin-bottom: 5px;
        }
        .history-img-box img { width: 100%; height: 100%; object-fit: cover; }
        .history-slot.reversed .history-img-box img { transform: rotate(180deg); }
        .history-text { font-size: 9px; color: #aaa; text-align: center; line-height: 1.2; font-family: 'Noto Serif SC'; }
        .history-text span.rev-mark { color: #ff6b6b; font-size: 8px; display: block; }

        /* å¡ç‰Œè¯¦æƒ… */
        #card-detail { 
            position: absolute; bottom: 2%; left: 50%; transform: translateX(-50%); 
            text-align: center; opacity: 0; transition: opacity 1s; width: 100%; max-width: 700px;
        }
        #card-name { font-size: 42px; color: #d4af37; letter-spacing: 5px; margin-bottom: 10px; text-shadow: 0 2px 20px rgba(0,0,0,1); }
        #card-sub { font-size: 14px; color: #888; margin-bottom: 25px; letter-spacing: 3px; text-transform: uppercase; display: none; }
        #card-desc { font-size: 18px; color: #ddd; text-shadow: 0 2px 4px #000; line-height: 1.8; font-family: 'Noto Serif SC', serif; display: none;}
        #burn-hint {  font-size: 12px; color: rgba(255,255,255,0.6); letter-spacing: 2px; animation: breathe 3s infinite; }
        @keyframes breathe { 0%,100%{opacity:0.4} 50%{opacity:1} }

        /* ==================== é˜¶æ®µ3ï¼šè§£è¯»å±‚ (Reading Layer) ==================== */
        #reading-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            display: none; flex-direction: column; justify-content: flex-start; align-items: center;
            opacity: 0; transition: opacity 1s; padding: 40px 20px;
            overflow: hidden;
        }
        #reading-content { 
            width: 100%; 
            max-width: 700px; 
            text-align: center; 
            display: flex; 
            flex-direction: column; 
            height: 100%;
            max-height: 100vh;
            padding: 0 20px;
        }
        #reading-title { 
            color: #d4af37; 
            font-size: 24px; 
            margin-bottom: 30px; 
            letter-spacing: 4px; 
            flex-shrink: 0;
        }
        #reading-text { 
            color: #eee; 
            font-size: 16px; 
            line-height: 2; 
            font-family: 'Noto Serif SC'; 
            white-space: pre-wrap; 
            text-align: left; 
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            padding: 20px;
            padding-right: 10px;
            margin-bottom: 20px;
            /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: rgba(212, 175, 55, 0.5) rgba(0, 0, 0, 0.3);
        }
        #reading-text::-webkit-scrollbar {
            width: 8px;
        }
        #reading-text::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        #reading-text::-webkit-scrollbar-thumb {
            background: rgba(212, 175, 55, 0.5);
            border-radius: 4px;
        }
        #reading-text::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 175, 55, 0.7);
        }
        #restart-btn { 
            margin-top: 20px; 
            opacity: 0; 
            flex-shrink: 0;
        }

        /* è°ƒè¯•ä¸è¾…åŠ© */
        #input-video { position: absolute; bottom: 10px; right: 10px; width: 100px; height: 75px; transform: scaleX(-1); opacity: 0; z-index: 0; transition: opacity 0.5s; border: 1px solid #333; }
        #input-video.active { opacity: 0.2; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #444; font-size: 12px; letter-spacing: 2px; z-index: 100; transition: opacity 0.5s; }
        .lil-gui { top: auto !important; bottom: 20px !important; right: 20px !important; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...</div>

    <div id="canvas-container"></div>
    <video id="input-video" playsinline></video>

    <!-- é˜¶æ®µ1ï¼šæé—® -->
    <div id="intro-layer">
        <div class="intro-text">
            åœ¨å¿ƒé‡Œæƒ³ä¸€ä¸ªé—®é¢˜<br>
            <span style="font-size:12px; color:#666; display:block; margin-top:10px;">æˆ–è€…æŠŠå®ƒç•™åœ¨è¿™é‡Œ...</span>
        </div>
        <input type="text" id="user-question" class="soul-input" placeholder="ï¼ˆæ­¤å¤„ç•™ç™½äº¦å¯ï¼‰" autocomplete="off">
        <button id="start-btn" class="start-btn">å‡è§†æ˜Ÿç©º</button>
    </div>

    <!-- é˜¶æ®µ2ï¼šæŠ½ç‰Œ -->
    <div id="ui-layer">
        <div id="history-bar"></div>
        <div id="status-bar">
            <div id="st-browse" class="status-item"><div class="status-icon">ğŸ–</div><div class="status-label">æ„Ÿåº”</div></div>
            <div id="st-grab" class="status-item"><div class="status-icon">âœŠ</div><div class="status-label">æ•è·</div></div>
            <div id="st-release" class="status-item"><div class="status-icon">ğŸ–</div><div class="status-label">å½’ä½</div></div>
        </div>
        <div id="card-detail">
            <div id="card-name"></div><div id="card-sub"></div><div id="card-desc"></div>
            <div id="burn-hint">å†æ¬¡å¼ å¼€æ‰‹æŒï¼Œæ¥çº³æŒ‡å¼•...</div>
        </div>
    </div>

    <!-- é˜¶æ®µ3ï¼šè§£è¯» -->
    <div id="reading-layer">
        <div id="reading-content">
            <div id="reading-title">âœ¦ å¯ ç¤º âœ¦</div>
            <div id="reading-text"></div>
            <button id="restart-btn" class="start-btn" onclick="location.reload()">é‡æ–°æé—®</button>
        </div>
    </div>

<script>
const CONFIG = { spreadRadius: 22, spreadWidth: 3.5, scrollSpeed: 0.08, cursorSmooth: 0.15, cameraZ: 6.5 };
const AURA_PARAMS = { count: 3000, radiusX: 1.2, radiusY: 1.8, width: 0.3, size: 0.04, color: '#ffffff', speed: 0.02, opacity: 0.8 };

// DeepSeek API é…ç½®
// æ–¹å¼1ï¼šä½¿ç”¨åç«¯ä»£ç†ï¼ˆæ¨èï¼Œæ›´å®‰å…¨ï¼‰
const DEEPSEEK_CONFIG = {
    useProxy: true, // è®¾ç½®ä¸º true ä½¿ç”¨åç«¯ä»£ç†ï¼Œfalse ç›´æ¥è°ƒç”¨ API
    proxyURL: 'http://localhost:3001/api/tarot-reading', // åç«¯ä»£ç†åœ°å€
    // æ–¹å¼2ï¼šç›´æ¥è°ƒç”¨ APIï¼ˆä¸æ¨èï¼Œä¼šæš´éœ² API Keyï¼‰
    apiKey: '', // ä»…åœ¨ useProxy=false æ—¶ä½¿ç”¨
    baseURL: 'https://api.deepseek.com/v1/chat/completions',
    model: 'deepseek-reasoner' 
};

const MAJORS_INFO = [
    { n: "æ„šè€…", e: "The Fool", m: "æ–°çš„å¼€å§‹ Â· å†’é™© Â· çº¯çœŸ" }, { n: "é­”æœ¯å¸ˆ", e: "The Magician", m: "åˆ›é€ åŠ› Â· æ„å¿— Â· æ˜¾åŒ–" }, { n: "å¥³ç¥­å¸", e: "The High Priestess", m: "ç›´è§‰ Â· ç¥ç§˜ Â· æ½œæ„è¯†" }, { n: "çš‡å", e: "The Empress", m: "ä¸°é¥¶ Â· è‡ªç„¶ Â· æ¯æ€§" }, { n: "çš‡å¸", e: "The Emperor", m: "æƒå¨ Â· ç»“æ„ Â· æ§åˆ¶" }, { n: "æ•™çš‡", e: "The Hierophant", m: "ä¼ ç»Ÿ Â· ä¿¡ä»° Â· æ•™è‚²" }, { n: "æ‹äºº", e: "The Lovers", m: "çˆ± Â· å’Œè° Â· é€‰æ‹©" }, { n: "æˆ˜è½¦", e: "The Chariot", m: "èƒœåˆ© Â· æ„å¿— Â· è‡ªå¾‹" }, { n: "åŠ›é‡", e: "Strength", m: "å‹‡æ°” Â· è€å¿ƒ Â· åŒæƒ…" }, { n: "éšå£«", e: "The Hermit", m: "å†…çœ Â· å­¤ç‹¬ Â· æŒ‡å¼•" }, { n: "å‘½è¿ä¹‹è½®", e: "Wheel of Fortune", m: "å‘¨æœŸ Â· å˜åŒ– Â· è¿æ°”" }, { n: "æ­£ä¹‰", e: "Justice", m: "å…¬å¹³ Â· çœŸç† Â· å› æœ" }, { n: "å€’åŠäºº", e: "The Hanged Man", m: "ç‰ºç‰² Â· æ–°è§†è§’ Â· æ”¾æ‰‹" }, { n: "æ­»ç¥", e: "Death", m: "ç»“æŸ Â· è½¬å˜ Â· é‡ç”Ÿ" }, { n: "èŠ‚åˆ¶", e: "Temperance", m: "å¹³è¡¡ Â· é€‚åº¦ Â· èåˆ" }, { n: "æ¶é­”", e: "The Devil", m: "æŸç¼š Â· æ¬²æœ› Â· è¯±æƒ‘" }, { n: "é«˜å¡”", e: "The Tower", m: "çªå˜ Â· æ··ä¹± Â· è§‰é†’" }, { n: "æ˜Ÿæ˜Ÿ", e: "The Star", m: "å¸Œæœ› Â· çµæ„Ÿ Â· æ²»æ„ˆ" }, { n: "æœˆäº®", e: "The Moon", m: "å¹»è§‰ Â· ä¸å®‰ Â· æ½œæ„è¯†" }, { n: "å¤ªé˜³", e: "The Sun", m: "å¿«ä¹ Â· æˆåŠŸ Â· æ´»åŠ›" }, { n: "å®¡åˆ¤", e: "Judgement", m: "å¤æ´» Â· è§‰é†’ Â· å¬å”¤" }, { n: "ä¸–ç•Œ", e: "The World", m: "å®Œæˆ Â· æ•´åˆ Â· åœ†æ»¡" }
];
const MINORS_SUITS = [ { id: 'wands', name: 'æƒæ–', key: 'ç«' }, { id: 'cups', name: 'åœ£æ¯', key: 'æ°´' }, { id: 'swords', name: 'å®å‰‘', key: 'é£' }, { id: 'pentacles', name: 'æ˜Ÿå¸', key: 'åœŸ' } ];
const MINORS_RANKS = [ { id: 'ace', cn: 'é¦–ç‰Œ', m: 'æ–°å¼€ç«¯' }, { id: '2', cn: '2', m: 'å¹³è¡¡ä¸å†³å®š' }, { id: '3', cn: '3', m: 'åˆä½œ' }, { id: '4', cn: '4', m: 'ç¨³å®š' }, { id: '5', cn: '5', m: 'å†²çª' }, { id: '6', cn: '6', m: 'èƒœåˆ©' }, { id: '7', cn: '7', m: 'åšæŒ' }, { id: '8', cn: '8', m: 'å˜åŒ–' }, { id: '9', cn: '9', m: 'éŸ§æ€§' }, { id: '10', cn: '10', m: 'åœ†æ»¡' }, { id: 'page', cn: 'ä¾ä»', m: 'å¥½å¥‡' }, { id: 'knight', cn: 'éª‘å£«', m: 'è¡ŒåŠ¨' }, { id: 'queen', cn: 'ç‹å', m: 'ç†è§£' }, { id: 'king', cn: 'å›½ç‹', m: 'æŒæ§' } ];

let RAW_DECK = [];
MAJORS_INFO.forEach((info, index) => { RAW_DECK.push({ ...info, type: 'Major Arcana', url: `major_${index}.jpg` }); });
MINORS_SUITS.forEach(suit => { MINORS_RANKS.forEach(rank => { RAW_DECK.push({ n: `${suit.name}${rank.cn}`, e: `${rank.cn} of ${suit.name}`, m: `${suit.key} Â· ${rank.m}`, type: 'Minor Arcana', url: `${suit.id}_${rank.id}.jpg` }); }); });

/**
 * Fisher-Yates æ´—ç‰Œç®—æ³•
 * ç”¨äºéšæœºåŒ–ç‰Œç»„çš„é¡ºåº
 */
function shuffleDeck(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

/**
 * æŒ‰ç…§å¡”ç½—è§„åˆ™åˆ›å»ºå¹¶æ´—ç‰Œ
 * æ¨¡æ‹ŸçœŸå®å¡”ç½—å®è·µï¼šåœ¨æ´—ç‰Œè¿‡ç¨‹ä¸­ç¿»è½¬ä¸€äº›ç‰Œ
 * - ä½¿ç”¨30%-60%ä¹‹é—´çš„é€†ä½ç‡ï¼ˆæ¯è½®å¯å˜åŒ–ï¼Œåˆ›é€ "å‘½è¿æ°›å›´"ï¼‰
 * - æ´—ç‰Œå®Œæˆåï¼Œæ¯å¼ ç‰Œçš„æ–¹å‘å›ºå®šï¼ŒæŠ½ç‰Œæ—¶ä¸å†éšæœº
 */
function createTarotDeck(rawDeck) {
    // 1. å…ˆæ´—ç‰Œï¼ŒéšæœºåŒ–ç‰Œçš„é¡ºåºï¼ˆFisher-Yatesç®—æ³•ï¼‰
    const shuffled = shuffleDeck(rawDeck);
    
    // 2. ç¡®å®šæœ¬è½®æ´—ç‰Œçš„é€†ä½ç‡ï¼ˆ30%-60%ä¹‹é—´ï¼Œåˆ›é€ "å‘½è¿æ°›å›´"ï¼‰
    // æ¯è½®æ¸¸æˆå¯èƒ½ä¸åŒçš„é€†ä½ç‡ï¼Œè®©æŸäº›è½®è‡ªç„¶åŒ…å«æ›´å¤šé€†ä½ç‰Œ
    const reversedRate = 0.3 + Math.random() * 0.3; // 0.3 åˆ° 0.6 ä¹‹é—´
    
    // 3. ä¸ºæ¯å¼ ç‰Œåˆ†é…å›ºå®šçš„æ–¹å‘ï¼ˆåœ¨æ´—ç‰Œé˜¶æ®µç¡®å®šï¼Œè€Œä¸æ˜¯æŠ½ç‰Œæ—¶ï¼‰
    // æ¨¡æ‹Ÿæ´—ç‰Œè¿‡ç¨‹ä¸­æŸäº›ç‰Œè¢«ç¿»è½¬çš„æƒ…å†µ
    const deck = shuffled.map(card => ({
        ...card,
        isReversed: Math.random() < reversedRate // æ ¹æ®é€†ä½ç‡å†³å®šæ˜¯å¦é€†ä½
    }));
    
    // 4. æ–¹å‘å·²å›ºå®šï¼Œè¿”å›æ´—å¥½çš„ç‰Œç»„
    return deck;
}

const getImg = (path) => {
    // å¦‚æœæ˜¯å®Œæ•´URLï¼Œç›´æ¥è¿”å›
    if (path.startsWith('http://') || path.startsWith('https://')) {
        return path;
    }
    // ä½¿ç”¨åŸºäºå½“å‰é¡µé¢ä½ç½®çš„è·¯å¾„ï¼Œå…¼å®¹CDNéƒ¨ç½²
    // å¦‚æœé¡µé¢åœ¨æ ¹ç›®å½•ï¼Œä½¿ç”¨ /assets/ï¼›å¦‚æœåœ¨å­ç›®å½•ï¼Œä½¿ç”¨ç›¸å¯¹äºå½“å‰ç›®å½•çš„è·¯å¾„
    const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
    const imgPath = `${basePath}assets/${path}`;
    console.log('Loading image:', imgPath); // è°ƒè¯•ä¿¡æ¯
    return imgPath;
}; 

/* SHADERS */
const ashVertexShader = `uniform float uTime; uniform float uSpeed; uniform float uSize; uniform float uSpread; attribute float aRandom; attribute vec3 aColor; varying vec3 vColor; varying float vAlpha; vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;} float snoise(vec3 v){ const vec2 C=vec2(1.0/6.0,1.0/3.0); const vec4 D=vec4(0.0,0.5,1.0,2.0); vec3 i=floor(v+dot(v,C.yyy)); vec3 x0=v-i+dot(i,C.xxx); vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g; vec3 i1=min(g.xyz,l.zxy); vec3 i2=max(g.xyz,l.zxy); vec3 x1=x0-i1+C.xxx; vec3 x2=x0-i2+C.yyy; vec3 x3=x0-D.yyy; i=mod289(i); vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0)); float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx; vec4 j=p-49.0*floor(p*ns.z*ns.z); vec4 x_=floor(j*ns.z); vec4 y_=floor(j-7.0*x_); vec4 x=x_*ns.x+ns.yyyy; vec4 y=y_*ns.x+ns.yyyy; vec4 h=1.0-abs(x)-abs(y); vec4 b0=vec4(x.xy,y.xy); vec4 b1=vec4(x.zw,y.zw); vec4 s0=floor(b0)*2.0+1.0; vec4 s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0)); vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw+s1.xzyw*sh.zzww; vec3 p0=vec3(a0.xy,h.x); vec3 p1=vec3(a0.zw,h.y); vec3 p2=vec3(a1.xy,h.z); vec3 p3=vec3(a1.zw,h.w); vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w; vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m=m*m; return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3))); } void main() { vColor = aColor; float t = uTime * (1.0 + aRandom * 0.5); vec3 noisePos = position * 0.5 + vec3(0.0, t * 0.5, 0.0); float noiseVal = snoise(noisePos); vec3 newPos = position; newPos.y += t * 2.0; newPos.x += noiseVal * t * uSpread; newPos.z += noiseVal * t * uSpread; vAlpha = 1.0 - smoothstep(0.0, 2.5, t); vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0); gl_PointSize = (uSize * aRandom + 2.0) * (1.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
const ashFragmentShader = `varying vec3 vColor; varying float vAlpha; void main() { if (vAlpha <= 0.0) discard; vec2 coord = gl_PointCoord - vec2(0.5); float dist = length(coord); if(dist > 0.5) discard; float glow = 1.0 - (dist * 2.0); gl_FragColor = vec4(vColor, vAlpha * glow); }`;
const auraVertexShader = `uniform float uTime; uniform float uSize; attribute float aRandom; attribute float aAngle; attribute float aRadius; varying float vAlpha; void main() { vec3 newPos = position; float twinkle = 0.5 + 0.5 * sin(uTime * 2.0 + aRandom * 10.0); vAlpha = twinkle; vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0); gl_PointSize = (uSize * aRandom + 10.0) * (1.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
const auraFragmentShader = `uniform vec3 uColor; uniform float uOpacity; varying float vAlpha; void main() { vec2 coord = gl_PointCoord - vec2(0.5); float dist = length(coord); if(dist > 0.5) discard; float strength = 1.0 - (dist * 2.0); strength = pow(strength, 2.0); gl_FragColor = vec4(uColor, vAlpha * uOpacity * strength); }`;

class TarotSpace {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.w = window.innerWidth; this.h = window.innerHeight;
        this.cards = []; this.particles = [];
        
        // æ¸¸æˆçŠ¶æ€ç®¡ç†
        this.gameState = 'intro'; // intro -> playing -> reading
        this.gestureState = 'browsing'; // playingçŠ¶æ€ä¸‹çš„å­çŠ¶æ€: browsing, revealed
        this.gestureMode = 'none'; 
        
        this.drawnCards = []; // å·²æŠ½å–çš„ç‰Œ
        this.maxCards = 3;
        
        // æŒ‰ç…§å¡”ç½—è§„åˆ™åˆ›å»ºå¹¶æ´—ç‰Œï¼ˆæ¯æ¬¡åˆå§‹åŒ–æ—¶è¿›è¡Œä¸€æ¬¡ï¼Œæ–¹å‘å›ºå®šï¼‰
        this.tarotDeck = createTarotDeck(RAW_DECK);
        
        this.scrollOffset = 0; this.targetScrollOffset = 0;
        this.hoveredCard = null; this.revealedCard = null;
        this.handPos = { x: 0, y: 0 };
        this.cursorPos = new THREE.Vector2(0,0);
        this.targetCursorPos = new THREE.Vector2(0,0);
        
        this.texLoader = new THREE.TextureLoader();
        this.texLoader.setCrossOrigin('anonymous');
        
        this.initThree();
        this.backTexture = this.generateCardTexture(); 
        this.loadLocalBack(); 

        this.initCards(); // åˆå§‹åŒ–æ—¶ä¸æ˜¾ç¤ºï¼Œç­‰å¾… start
        this.initCursor(); 
        this.initAura();   
        this.initBackgroundStars();
        this.initMediaPipe();
        this.initMouse();
        this.initDOM(); // ç»‘å®šDOMäº‹ä»¶

        this.animate();
        
        // åŠ è½½å®Œæˆ
        document.getElementById('loading').style.display = 'none';
    }

    initDOM() {
        const startBtn = document.getElementById('start-btn');
        const userQ = document.getElementById('user-question');
        
        startBtn.addEventListener('click', () => {
            const question = userQ.value.trim();
            console.log("User Question:", question || "Silent contemplation");
            this.startSession();
        });
    }

    startSession() {
        // 1. UI åˆ‡æ¢
        const intro = document.getElementById('intro-layer');
        intro.classList.add('fade-exit');
        
        const ui = document.getElementById('ui-layer');
        ui.classList.add('active'); // å…è®¸ pointer-events

        // 2. çŠ¶æ€åˆ‡æ¢
        this.gameState = 'playing';
        this.gestureState = 'browsing';

        // 3. å¡ç‰Œå…¥åœºåŠ¨ç”» (æ¨¡æ‹Ÿæ´—ç‰Œ)
        this.cards.forEach((group, i) => {
            group.position.set(0, 0, -50); // å…ˆæ”¾è¿œ
            group.visible = true;
            
            // éšæœºå»¶è¿Ÿé£å…¥
            new TWEEN.Tween(group.position)
                .to({ z: -5 }, 1500)
                .delay(i * 10) // é”™è½æœ‰è‡´
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        });
    }

    async finishSession() {
        this.gameState = 'reading';
        
        const readingLayer = document.getElementById('reading-layer');
        const readingText = document.getElementById('reading-text');
        
        readingLayer.style.display = 'flex';
        void readingLayer.offsetWidth; 
        readingLayer.style.opacity = 1;

        const question = document.getElementById('user-question').value || "æ— å£°çš„å›°æƒ‘";
        const cardsStr = this.drawnCards.map(c => 
            `${c.name}${c.isReversed ? '(é€†ä½)' : '(æ­£ä½)'}`
        ).join(' â†’ ');

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        readingText.textContent = 'æ˜Ÿè¾°æ­£åœ¨æ±‡èš...\n\nè¯·ç¨å€™ï¼Œå‘½è¿ä¹‹è½®æ­£åœ¨è½¬åŠ¨...';

        try {
            // è°ƒç”¨ DeepSeek API
            const interpretation = await this.callDeepSeekAPI(question, this.drawnCards);
            this.displayReading(readingText, question, cardsStr, interpretation);
        } catch (error) {
            console.error('DeepSeek API è°ƒç”¨å¤±è´¥:', error);
            // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ–‡æœ¬
            const fallbackText = `ä½ çš„é—®é¢˜ï¼š${question}\n\nç‰Œé˜µæŒ‡å¼•ï¼š\n${cardsStr}\n\nâš ï¸ API è°ƒç”¨å¤±è´¥: ${error.message}\n\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œ API Key é…ç½®ã€‚\n\næ˜Ÿè¾°ä½è¯­ï¼š\nå‘½è¿ä¸æ˜¯æ—¢å®šçš„è½¨é“ï¼Œè€Œæ˜¯å½“ä¸‹çš„é€‰æ‹©ã€‚è¿™ä¸‰å¼ ç‰Œåˆ†åˆ«ä»£è¡¨äº†ä½ å½“ä¸‹çš„å¤„å¢ƒã€é¢ä¸´çš„æŒ‘æˆ˜ä»¥åŠå¯èƒ½çš„æŒ‡å¼•...`;
            this.displayReading(readingText, question, cardsStr, fallbackText);
        }
    }

    async callDeepSeekAPI(question, cards) {
        // ä½¿ç”¨åç«¯ä»£ç†ï¼ˆæ¨èæ–¹å¼ï¼‰
        if (DEEPSEEK_CONFIG.useProxy) {
            const response = await fetch(DEEPSEEK_CONFIG.proxyURL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question: question,
                    cards: cards,
                    model: DEEPSEEK_CONFIG.model
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `ä»£ç†è¯·æ±‚å¤±è´¥: ${response.status}`);
            }

            const data = await response.json();
            return data.choices[0]?.message?.content || 'æœªèƒ½è·å–è§£è¯»å†…å®¹';
        }
        
        // ç›´æ¥è°ƒç”¨ APIï¼ˆä¸æ¨èï¼Œä¼šæš´éœ² API Keyï¼‰
        if (!DEEPSEEK_CONFIG.apiKey) {
            throw new Error('API Key æœªé…ç½®ï¼Œè¯·è®¾ç½® DEEPSEEK_CONFIG.apiKey æˆ–ä½¿ç”¨åç«¯ä»£ç†ï¼ˆè®¾ç½® useProxy: trueï¼‰');
        }

        const cardsDescription = cards.map((c, index) => {
            const position = ['è¿‡å»/ç°çŠ¶', 'ç°åœ¨/æŒ‘æˆ˜', 'æœªæ¥/æŒ‡å¼•'][index] || 'æœªçŸ¥';
            return `${position}: ${c.name}${c.isReversed ? '(é€†ä½)' : '(æ­£ä½)'}`;
        }).join('\n');

        const systemPrompt = `ä½ æ˜¯ä¸€ä½èµ„æ·±çš„å¡”ç½—ç‰Œè§£è¯»å¸ˆï¼Œæ“…é•¿ç”¨è¯—æ„è€Œæ·±åˆ»çš„è¯­è¨€è§£è¯»å¡”ç½—ç‰Œçš„å«ä¹‰ã€‚è¯·æ ¹æ®ç”¨æˆ·çš„é—®é¢˜å’Œä¸‰å¼ å¡”ç½—ç‰Œï¼Œæä¾›ä¸€ä»½æ·±åˆ»è€Œæœ‰å¯å‘æ€§çš„è§£è¯»ã€‚`;
        const userPrompt = `é—®é¢˜ï¼š${question}\n\næŠ½åˆ°çš„ä¸‰å¼ ç‰Œï¼š\n${cardsDescription}\n\nè¯·æä¾›ä¸€ä»½è¯¦ç»†çš„å¡”ç½—ç‰Œè§£è¯»ï¼ŒåŒ…æ‹¬ï¼š\n1. å¯¹é—®é¢˜çš„æ•´ä½“åˆ†æ\n2. æ¯å¼ ç‰Œçš„å«ä¹‰åŠå…¶åœ¨é—®é¢˜ä¸­çš„æ„ä¹‰\n3. ä¸‰å¼ ç‰Œä¹‹é—´çš„å…³è”å’Œæ•´ä½“æŒ‡å¼•\n4. ç»™äºˆå»ºè®®æˆ–å¯ç¤º\n\nè¯·ç”¨ä¼˜é›…ã€å¯Œæœ‰è¯—æ„çš„ä¸­æ–‡å›ç­”ï¼Œè¯­è¨€è¦æœ‰ç¥ç§˜æ„Ÿå’Œå¯å‘æ€§ã€‚`;

        const response = await fetch(DEEPSEEK_CONFIG.baseURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`
            },
            body: JSON.stringify({
                model: DEEPSEEK_CONFIG.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: 0.8,
                max_tokens: 2000
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} ${errorData.error?.message || response.statusText}`);
        }

        const data = await response.json();
        return data.choices[0]?.message?.content || 'æœªèƒ½è·å–è§£è¯»å†…å®¹';
    }

    displayReading(readingTextElement, question, cardsStr, interpretation) {
        const fullText = `ä½ çš„é—®é¢˜ï¼š${question}\n\nç‰Œé˜µæŒ‡å¼•ï¼š\n${cardsStr}\n\n${'â”€'.repeat(40)}\n\n${interpretation}`;
        
        // æ‰“å­—æœºæ•ˆæœ
        readingTextElement.textContent = '';
        let i = 0;
        const typeWriter = setInterval(() => {
            readingTextElement.textContent += fullText.charAt(i);
            i++;
            if (i >= fullText.length) {
                clearInterval(typeWriter);
                // æ˜¾ç¤ºé‡å¼€æŒ‰é’®
                new TWEEN.Tween(document.getElementById('restart-btn').style)
                    .to({ opacity: 1 }, 1000).start();
            }
        }, 30);
    }

    // ... (generateMagicCursorTexture, generateCardTexture, loadLocalBack, createFrontTexture, initThree, initBackgroundStars, initAura, updateAura ä¿æŒä¸å˜)
    generateMagicCursorTexture() {
        const c = document.createElement('canvas'); c.width = 256; c.height = 256; const ctx = c.getContext('2d');
        const cx = 128, cy = 128; ctx.strokeStyle = '#d4af37'; ctx.shadowBlur = 10; ctx.shadowColor = '#d4af37';
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, 100, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(cx, cy, 90, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); for(let i=0; i<3; i++) { const a = (i * 120) * Math.PI/180; const x = cx + Math.cos(a)*90; const y = cy + Math.sin(a)*90; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.stroke();
        ctx.beginPath(); for(let i=0; i<3; i++) { const a = (i * 120 + 60) * Math.PI/180; const x = cx + Math.cos(a)*90; const y = cy + Math.sin(a)*90; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.stroke();
        ctx.font = '20px serif'; ctx.fillStyle = '#d4af37'; ctx.textAlign='center'; ctx.fillText('âš¡', cx, cy+8);
        return new THREE.CanvasTexture(c);
    }
    generateCardTexture() { const c = document.createElement('canvas'); c.width = 256; c.height = 400; const ctx = c.getContext('2d'); ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,256,400); ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10; ctx.strokeRect(10,10,236,380); ctx.beginPath(); ctx.arc(128, 200, 60, 0, Math.PI*2); ctx.stroke(); return new THREE.CanvasTexture(c); }
    loadLocalBack() { 
        const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
        const backPath = `${basePath}tarot-card-back.jpg`;
        console.log('Loading card back:', backPath); // è°ƒè¯•ä¿¡æ¯
        this.texLoader.load(backPath, (tex) => { 
            this.backTexture = tex; 
            this.cards.forEach(group => { 
                group.children[0].material.map = tex; 
                group.children[0].material.needsUpdate = true; 
            }); 
        }, undefined, (err) => console.warn("æœªæ‰¾åˆ°ç‰ŒèƒŒå›¾ç‰‡:", backPath)); 
    }
    createFrontTexture(data) { const c = document.createElement('canvas'); c.width = 512; c.height = 800; const ctx = c.getContext('2d'); ctx.fillStyle = '#f5f0e1'; ctx.fillRect(0,0,512,800); ctx.strokeStyle = '#333'; ctx.lineWidth = 15; ctx.strokeRect(20,20,472,760); ctx.fillStyle = '#111'; ctx.textAlign = 'center'; ctx.font = 'bold 50px serif'; ctx.fillText(data.e, 256, 300); ctx.font = '30px sans-serif'; ctx.fillStyle = '#555'; ctx.fillText(data.n, 256, 360); return new THREE.CanvasTexture(c); }
    initThree() { this.scene = new THREE.Scene(); this.camera = new THREE.PerspectiveCamera(60, this.w/this.h, 0.1, 100); this.camera.position.set(0, 0, CONFIG.cameraZ); this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); this.renderer.setSize(this.w, this.h); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.outputEncoding = THREE.LinearEncoding; this.container.appendChild(this.renderer.domElement); this.scene.add(new THREE.AmbientLight(0xffffff, 1.0)); }
    initBackgroundStars() { const count = 1500; const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<count; i++) pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*80-40); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({ color: 0x888888, size: 2, sizeAttenuation: false, transparent: true, opacity: 0.8 }); this.bgStars = new THREE.Points(geo, mat); this.scene.add(this.bgStars); }
    initAura() { const pCount = AURA_PARAMS.count; const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<pCount; i++) { const th = Math.random() * Math.PI * 2; const rx = AURA_PARAMS.radiusX + Math.random() * AURA_PARAMS.width; const ry = AURA_PARAMS.radiusY + Math.random() * AURA_PARAMS.width; pos.push(Math.cos(th)*rx, Math.sin(th)*ry, (Math.random()-0.5)*0.5); } geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({ color: AURA_PARAMS.color, size: AURA_PARAMS.size, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false }); this.aura = new THREE.Points(geo, mat); this.scene.add(this.aura); }
    updateAura() { if(!this.aura) return; this.aura.rotation.z += AURA_PARAMS.speed; if (this.gestureState === 'browsing' && this.hoveredCard) { this.aura.position.copy(this.hoveredCard.position); this.aura.position.z += AURA_PARAMS.zOffset; this.aura.rotation.y = this.hoveredCard.rotation.y; this.aura.material.opacity += (AURA_PARAMS.opacity - this.aura.material.opacity) * 0.1; } else { this.aura.material.opacity += (0 - this.aura.material.opacity) * 0.2; } }
    initCursor() { const tex = this.generateMagicCursorTexture(); this.cursorMesh = new THREE.Mesh( new THREE.PlaneGeometry(0.6, 0.6), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.8, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthTest: false }) ); this.cursorMesh.visible = false; this.scene.add(this.cursorMesh); this.raycaster = new THREE.Raycaster(); }

    initCards() {
        const geo = new THREE.PlaneGeometry(2.0, 3.2);
        const count = this.tarotDeck.length;
        const backMat = new THREE.MeshBasicMaterial({ map: this.backTexture, color: 0xffffff, side: THREE.FrontSide });
        const frontMat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.FrontSide });

        for (let i = 0; i < count; i++) {
            const group = new THREE.Group();
            const back = new THREE.Mesh(geo, backMat); back.position.z = 0.01; back.rotation.y = 0;
            const front = new THREE.Mesh(geo, frontMat); front.position.z = -0.01; front.rotation.y = Math.PI;
            group.add(back); group.add(front);
            
            // åˆå§‹åœ¨å±å¹•å¤–ï¼Œvisible false
            group.visible = false;
            group.userData = { id: i, info: this.tarotDeck[i], baseX: (i - count/2) * CONFIG.spreadWidth };
            this.scene.add(group);
            this.cards.push(group);
        }
    }

    updateLayout() {
        if (this.gameState !== 'playing') return; // åªåœ¨æ¸¸æˆé˜¶æ®µæ›´æ–°
        if (this.gestureState === 'revealed' || this.gestureState === 'burning') return;
        
        this.scrollOffset += (this.targetScrollOffset - this.scrollOffset) * 0.1;
        if(this.cursorMesh.visible) this.cursorMesh.rotation.z -= 0.02;

        this.cards.forEach((card) => {
            const worldX = card.userData.baseX + this.scrollOffset;
            const dist = Math.abs(worldX);
            if (dist > 8.0) { card.visible = false; return; }
            card.visible = true;

            card.position.x = worldX;
            card.position.z = -Math.pow(dist * 0.25, 1.5);
            card.rotation.y = Math.max(-0.5, Math.min(0.5, -worldX * 0.06));

            if (this.gestureState === 'browsing' && this.hoveredCard === card) {
                card.scale.setScalar(1.1); card.position.z += 1.5; card.rotation.y = 0;
            } else {
                card.scale.setScalar(1.0);
            }
        });
    }

    handleGestures() {
        if (this.gameState !== 'playing') return;
        if (this.gestureState === 'burning') return;
        
        ['st-browse', 'st-grab', 'st-release'].forEach(id => document.getElementById(id).classList.remove('active'));

        if (this.gestureState === 'browsing') {
            if (this.gestureMode === 'open') {
                document.getElementById('st-browse').classList.add('active');
                if (Math.abs(this.handPos.x) > 0.3) {
                    const speed = CONFIG.scrollSpeed;
                    if (this.handPos.x < 0) this.targetScrollOffset += speed * (Math.abs(this.handPos.x)*1.5);
                    else this.targetScrollOffset -= speed * (Math.abs(this.handPos.x)*1.5);
                    
                    const limit = (this.cards.length/2)*CONFIG.spreadWidth + 2;
                    this.targetScrollOffset = Math.max(-limit, Math.min(limit, this.targetScrollOffset));
                    this.cursorMesh.visible = false; this.hoveredCard = null;
                } else {
                    this.cursorMesh.visible = true;
                    this.cursorPos.lerp(this.targetCursorPos, CONFIG.cursorSmooth);
                    const vec = new THREE.Vector3(this.cursorPos.x, this.cursorPos.y, 0.5); vec.unproject(this.camera);
                    const dir = vec.sub(this.camera.position).normalize();
                    const pos = this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z/dir.z));
                    this.cursorMesh.position.copy(pos);
                    
                    this.raycaster.setFromCamera(this.cursorPos, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.cards.filter(c => c.visible), true);
                    if (intersects.length > 0) {
                        let target = intersects[0].object; while(target.parent && !target.userData.id) target = target.parent;
                        this.hoveredCard = target;
                    } else this.hoveredCard = null;
                }
            } 
            else if (this.gestureMode === 'fist') {
                document.getElementById('st-grab').classList.add('active');
                if (this.hoveredCard) this.revealCard(this.hoveredCard);
            }
        } 
        else if (this.gestureState === 'revealed') {
            document.getElementById('st-release').classList.add('active');
            if (this.gestureMode === 'open') {
                this.burnCard();
            }
        }
    }

    revealCard(cardGroup) {
        if (this.gestureState === 'revealed') return;
        this.gestureState = 'revealed'; 
        this.revealedCard = cardGroup; this.cursorMesh.visible = false;

        document.getElementById('burn-hint').style.display = 'block';

        const data = cardGroup.userData.info;
        const frontMesh = cardGroup.children[1];
        
        frontMesh.material = new THREE.MeshBasicMaterial({ side: THREE.FrontSide, color: 0xffffff });

        // ç«‹å³ä»ç‰Œå †ä¸­ç§»é™¤ï¼Œé¿å…é‡å¤æŠ½å–
        const idx = this.cards.indexOf(cardGroup);
        if (idx > -1) {
            this.cards.splice(idx, 1);
            // é‡æ–°è®¡ç®—å‰©ä½™ç‰Œçš„ baseX ä½ç½®
            this.cards.forEach((group, i) => {
                group.userData.baseX = (i - this.cards.length/2) * CONFIG.spreadWidth;
            });
        }

        // ç«‹å³ä¿å­˜ç‰Œçš„ä¿¡æ¯ï¼ˆåŒæ­¥æ‰§è¡Œï¼‰ï¼Œç¡®ä¿åç»­å¯ä»¥è®¿é—®
        this.drawnCards.push({ name: data.n, isReversed: data.isReversed, img: data.url });
        
        this.texLoader.load(getImg(data.url), (tex) => { 
            frontMesh.material.map = tex; frontMesh.material.needsUpdate = true; 
        }, undefined, () => { 
            // å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å ä½çº¹ç†
            frontMesh.material.map = this.createFrontTexture(data); frontMesh.material.needsUpdate = true; 
            // æ›´æ–°å·²ä¿å­˜çš„è®°å½•ï¼Œä¿ç•™URLä»¥ä¾¿å†å²è®°å½•æ˜¾ç¤º
            const lastCard = this.drawnCards[this.drawnCards.length - 1];
            if (lastCard && lastCard.name === data.n) {
                lastCard.img = data.url; // ä»ç„¶ä¿ç•™URLï¼Œè®©addToHistoryå°è¯•åŠ è½½
            }
        });

        const targetRotZ = data.isReversed ? Math.PI : 0;

        new TWEEN.Tween(cardGroup.position).to({ x: 0, y: 0, z: CONFIG.cameraZ - 4 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
        new TWEEN.Tween(cardGroup.rotation).to({ x: 0, y: Math.PI, z: targetRotZ }, 1000).easing(TWEEN.Easing.Back.Out).start();

        this.cards.forEach(c => { new TWEEN.Tween(c.position).to({ z: -50 }, 800).start(); });
        setTimeout(() => {
            const revText = data.isReversed ? " (é€†ä½)" : "";
            document.getElementById('card-name').innerText = data.n + revText; 
            document.getElementById('card-sub').innerText = data.e; 
            document.getElementById('card-desc').innerText = data.m; 
            document.getElementById('card-detail').style.opacity = 1;
        }, 800);
    }

    addToHistory(imgUrl, isReversed, cardName) {
        const container = document.getElementById('history-bar');
        const slot = document.createElement('div');
        slot.className = `history-slot ${isReversed ? 'reversed' : ''}`;
        const imgBox = document.createElement('div');
        imgBox.className = 'history-img-box';
        
        // å§‹ç»ˆåˆ›å»ºimgå…ƒç´ ï¼Œå³ä½¿imgUrlä¸ºç©ºä¹Ÿåˆ›å»ºï¼ˆç”¨äºæ˜¾ç¤ºå ä½ç¬¦æˆ–è°ƒè¯•ï¼‰
        const img = document.createElement('img');
        if (imgUrl) {
            // ä½¿ç”¨åŸºäºå½“å‰é¡µé¢ä½ç½®çš„è·¯å¾„ï¼Œå…¼å®¹CDNéƒ¨ç½²
            const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
            const fullPath = `${basePath}assets/${imgUrl}`;
            img.src = fullPath;
            console.log('Loading history image:', fullPath); // è°ƒè¯•ä¿¡æ¯
            // æ·»åŠ é”™è¯¯å¤„ç†ï¼ŒåŠ è½½å¤±è´¥æ—¶æ˜¾ç¤ºå ä½ç¬¦
            img.onerror = function() {
                console.warn(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${fullPath}`);
                this.style.display = 'none'; // éšè—å¤±è´¥çš„å›¾ç‰‡ï¼Œæˆ–æ˜¾ç¤ºå ä½ç¬¦
            };
        } else {
            // å¦‚æœæ²¡æœ‰URLï¼Œåˆ›å»ºä¸€ä¸ªé€æ˜çš„å ä½ç¬¦
            img.style.opacity = '0.3';
            img.style.backgroundColor = 'rgba(212, 175, 55, 0.1)';
        }
        imgBox.appendChild(img);
        slot.appendChild(imgBox);
        
        const textBox = document.createElement('div');
        textBox.className = 'history-text';
        textBox.innerHTML = cardName + (isReversed ? '<br><span class="rev-mark">é€†ä½</span>' : '');
        slot.appendChild(textBox);
        container.appendChild(slot);
    }

    burnCard() {
        if (!this.revealedCard || this.gestureState === 'burning') return;
        this.gestureState = 'burning';
        
        // è¿™é‡Œçš„â€œburnâ€å…¶å®æ˜¯å½’ä½é€»è¾‘
        this.createAshEffect(this.revealedCard.position);
        
        // é£å‘å·¦ä¸Šè§’
        new TWEEN.Tween(this.revealedCard.position)
            .to({ x: -8, y: 5, z: -10 }, 800)
            .easing(TWEEN.Easing.Cubic.In)
            .start();
            
        new TWEEN.Tween(this.revealedCard.scale)
            .to({ x: 0, y: 0, z: 0 }, 800)
            .onComplete(() => {
                this.revealedCard.visible = false; 
                this.scene.remove(this.revealedCard);
                
                // æ·»åŠ åˆ° UI å†å²æ 
                const lastDrawn = this.drawnCards[this.drawnCards.length - 1];
                this.addToHistory(lastDrawn.img, lastDrawn.isReversed, lastDrawn.name);

                // ç‰Œå·²ç»åœ¨ revealCard() æ—¶ä» this.cards ä¸­ç§»é™¤äº†ï¼Œè¿™é‡Œåªéœ€è¦æ¸…ç†å¼•ç”¨
                this.revealedCard = null;
                
                // UI é‡ç½®
                document.getElementById('card-detail').style.opacity = 0;
                document.getElementById('burn-hint').style.display = 'none';

                // åˆ¤æ–­æ˜¯å¦ç»“æŸ
                if (this.drawnCards.length >= this.maxCards) {
                    this.finishSession();
                } else {
                    this.gestureState = 'browsing';
                }
            })
            .start();
    }

    createAshEffect(pos) {
        const count = 3000; const geo = new THREE.BufferGeometry(); const positions = [], randoms = [], colors = []; const color = new THREE.Color(0xd4af37);
        for(let i=0; i<count; i++) { positions.push((Math.random()-0.5)*2.0, (Math.random()-0.5)*3.2, 0); randoms.push(Math.random()); colors.push(color.r, color.g, color.b); }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geo.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1)); geo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.ShaderMaterial({ vertexShader: ashVertexShader, fragmentShader: ashFragmentShader, uniforms: { uTime: { value: 0 }, uSpeed: { value: 1.5 }, uSize: { value: 4.0 }, uSpread: { value: 0.5 } }, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
        const points = new THREE.Points(geo, material); points.position.copy(pos); this.scene.add(points); this.particles.push({ mesh: points, age: 0 });
    }

    initMediaPipe() {
        const vid = document.getElementById('input-video'); const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const idx = lm[8], thb = lm[4], wrs = lm[0], mid = lm[12], rng = lm[16], pnk = lm[20], idx_mcp = lm[5], pnk_mcp = lm[17];
                this.handPos.x = (1 - lm[9].x) * 2 - 1; this.targetCursorPos.x = (1 - idx.x) * 2 - 1; this.targetCursorPos.y = -(idx.y * 2 - 1);
                const dist = (a, b) => Math.sqrt(Math.pow(a.x-b.x,2) + Math.pow(a.y-b.y,2));
                const pinchDist = dist(idx, thb);
                const isFist = dist(idx, wrs)<0.3 && dist(mid, wrs)<0.25 && dist(rng, wrs)<0.25 && dist(pnk, wrs)<0.25;
                const isPinch = pinchDist < 0.05;
                const isOpen = dist(idx, wrs)>0.3 && dist(mid, wrs)>0.3 && dist(rng, wrs)>0.3 && dist(pnk, wrs)>0.3;
                const isPoint = dist(idx, wrs)>0.3 && dist(mid, wrs)<0.25; 
                if (isFist) this.gestureMode = 'fist'; else if (isPinch || isPoint) this.gestureMode = 'point'; else if (isOpen) this.gestureMode = 'open'; else this.gestureMode = 'none';
            } else this.gestureMode = 'none';
        });
        const camera = new Camera(vid, { onFrame: async () => { await hands.send({image: vid}); }, width: 320, height: 240 });
        camera.start();
    }

    initMouse() {
        window.addEventListener('mousemove', e => { const x = (e.clientX/this.w)*2-1; const y = -(e.clientY/this.h)*2+1; this.handPos.x = x; this.targetCursorPos.set(x, y); if (Math.abs(x)>0.4) this.gestureMode='open'; else this.gestureMode='point'; });
        window.addEventListener('mousedown', e => { if(e.button===0) this.gestureMode='fist'; }); 
        window.addEventListener('mouseup', () => { this.gestureMode='open'; }); 
        window.addEventListener('contextmenu', e => e.preventDefault());
    }

    animate() {
        requestAnimationFrame(() => this.animate()); TWEEN.update(); this.updateLayout(); this.updateAura(); this.handleGestures();
        if(this.bgStars) this.bgStars.rotation.y += 0.0002;
        for (let i = this.particles.length - 1; i >= 0; i--) { const p = this.particles[i]; p.age += 0.015; p.mesh.material.uniforms.uTime.value = p.age; if (p.age > 3.0) { this.scene.remove(p.mesh); this.particles.splice(i, 1); } }
        this.renderer.render(this.scene, this.camera);
    }
}
window.onload = () => new TarotSpace();
</script>
</body>
</html>